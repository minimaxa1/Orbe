<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbi (Ollama Advanced)</title>

    <style>
        /* --- CSS STYLES --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #000000; color: #ffffff;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 10px;
        }
        #particleCanvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; pointer-events: none; }

        .container {
            text-align: center; padding: 0; border-radius: 15px;
            max-width: 95%; /* Keep max-width constraint */
            width: 960px; /* MODIFIED: Increased width */
            position: relative; z-index: 1;
            display: flex; flex-direction: column;
            height: calc(100vh - 40px);
            background-color: #111;
            border: none;
            box-shadow: 0 5px 20px rgba(0,0,0,0.7);
            overflow: hidden;
        }

         .control-item {
             font-size: 0.8rem; padding: 5px 10px; border-radius: 6px;
             border: 1px solid rgba(100, 100, 100, 0.7); background-color: rgba(51, 51, 51, 0.7);
             color: #eee; cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease;
             height: 30px; display: inline-flex; align-items: center;
             vertical-align: middle; box-sizing: border-box; flex-shrink: 0;
         }
         .control-item:hover { background-color: rgba(68, 68, 68, 0.8); border-color: rgba(130, 130, 130, 0.8); }
         .control-item:active { background-color: rgba(85, 85, 85, 0.8); }
         select.control-item { min-width: 90px; max-width: 135px; padding-right: 20px; }
         button.control-item { min-width: 35px; justify-content: center; font-weight: bold; }

         #stopGeneratingButton { background-color: rgba(119, 0, 0, 0.7); display: none; border-color: rgba(170, 0, 0, 0.7); }
         #stopGeneratingButton:hover { background-color: rgba(170, 0, 0, 0.8); border-color: rgba(200, 0, 0, 0.8); }

         .tts-switch { display: flex; align-items: center; flex-shrink: 0; }
         #ttsToggle { opacity: 0; width: 0; height: 0; position: absolute; }
         label[for="ttsToggle"] { position: relative; display: inline-block; width: 38px; height: 20px; background-color: rgba(80, 80, 80, 0.7); border-radius: 10px; cursor: pointer; transition: background-color 0.3s ease; border: 1px solid rgba(100, 100, 100, 0.7); vertical-align: middle; }
         label[for="ttsToggle"]::after { content: ''; position: absolute; width: 16px; height: 16px; border-radius: 50%; background-color: #ccc; top: 1px; left: 2px; transition: transform 0.3s ease, background-color 0.3s ease; box-shadow: 0 1px 2px rgba(0,0,0,0.3); }
         #ttsToggle:checked + label[for="ttsToggle"] { background-color: rgba(70, 160, 90, 0.8); border-color: rgba(90, 180, 110, 0.8); }
         #ttsToggle:checked + label[for="ttsToggle"]::after { transform: translateX(17px); background-color: #fff; }

        .orb-shape-container { position: relative; width: 90px; height: 90px; margin: 15px auto 10px auto; cursor: default; z-index: 4; flex-shrink: 0; align-self: center; }
        .orb-shape { width: 100%; height: 100%; border-radius: 50%; border: 2px solid #cccccc; position: relative; z-index: 1; box-shadow: 0 4px 12px rgba(0,0,0,0.5), inset 0 2px 4px rgba(0,0,0,0.4); overflow: hidden; }
        #orbParticleCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%; pointer-events: none; z-index: 0; }

        .input-area { width: 100%; padding: 8px 15px; margin: 0; display: flex; align-items: center; gap: 10px; background-color: rgba(26, 26, 26, 0.8); border-top: 1px solid #333; flex-shrink: 0; z-index: 5; }
        #questionInput { flex-grow: 1; padding: 8px 12px; border: 1px solid #555; border-radius: 8px; font-size: 0.9rem; background-color: #252525; color: #ffffff; box-shadow: inset 0 1px 3px rgba(0,0,0,0.4); margin: 0; line-height: 1.4; max-height: 100px; resize: none; height: 32px; box-sizing: border-box; }
        #questionInput::placeholder { color: #aaa; opacity: 0.8; }
        #questionInput:focus { border-color: #888; outline: none; }
        #inputControlGroup { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }

        #chatDisplayArea { flex-grow: 1; width: 100%; overflow-y: auto; padding: 15px 20px; background-color: rgba(20, 20, 20, 0.08); border: none; display: flex; flex-direction: column-reverse; align-items: stretch; scrollbar-width: thin; scrollbar-color: rgba(85, 85, 85, 0.7) rgba(34, 34, 34, 0.5); }
        #chatDisplayArea::-webkit-scrollbar { width: 8px; }
        #chatDisplayArea::-webkit-scrollbar-track { background: rgba(34, 34, 34, 0.5); border-radius: 4px; }
        #chatDisplayArea::-webkit-scrollbar-thumb { background-color: rgba(85, 85, 85, 0.7); border-radius: 4px; }

        .message-pair { margin-bottom: 15px; max-width: 100%; display: flex; flex-direction: column; position: relative; }
        .user-message, .orbi-message, .thinking-message { padding: 10px 14px; padding-right: 35px; border-radius: 12px; line-height: 1.6; font-size: 14px; word-wrap: break-word; overflow-wrap: break-word; text-align: left; max-width: 90%; box-shadow: 0 1px 2px rgba(0,0,0,0.5); color: #f0f0f0; }
        .user-message { background-color: rgba(58, 58, 58, 0.6); align-self: flex-end; border-bottom-right-radius: 3px; }
        .orbi-message { background-color: rgba(40, 40, 40, 0.6); align-self: flex-start; border-bottom-left-radius: 3px; }
        .orbi-message i { color: #ffcccc; font-style: normal; }
        .thinking-message { background-color: rgba(32, 32, 32, 0.5); color: #bbb; align-self: flex-start; font-style: italic; border-bottom-left-radius: 3px; padding-right: 14px; }
        .message-label { font-weight: bold; display: block; margin-bottom: 4px; font-size: 0.8em; color: #ccc; }
        .copy-button { position: absolute; bottom: 5px; right: 5px; width: 24px; height: 24px; background-color: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); color: #ccc; border-radius: 4px; cursor: pointer; font-size: 12px; line-height: 22px; text-align: center; opacity: 0.4; transition: opacity 0.2s ease, background-color 0.2s ease; z-index: 1; }
        .orbi-message:hover .copy-button { opacity: 1; }
        .copy-button:hover { background-color: rgba(255, 255, 255, 0.2); }
        .copy-button:active { background-color: rgba(255, 255, 255, 0.3); }
        .copy-button.copied { opacity: 1; background-color: #3a7; color: #fff; }

        #systemInfo { position: absolute; bottom: 5px; left: 10px; font-size: 10px; color: #666; transition: opacity 0.8s ease-out; opacity: 1; z-index: 1; }
        @keyframes fadeInTextSimple { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>
    <canvas id="particleCanvas"></canvas>

    <div class="container">
         <!-- Orb -->
        <div class="orb-shape-container">
            <div class="orb-shape" id="orbShapeDiv">
                 <canvas id="orbParticleCanvas"></canvas>
            </div>
        </div>

        <!-- Chat history -->
        <div id="chatDisplayArea">
            <!-- Messages prepended here -->
        </div>

        <!-- Input area / Combined Bar -->
         <div class="input-area" id="inputArea">
            <input type="text" id="questionInput" placeholder="Ask Orbi">
            <div id="inputControlGroup">
                 <select id="modelSelector" class="control-item">
                     <option value="gemma3:12b" selected>Gemma3 12B</option>
                     <option value="deepseek-coder-v2">DeepSeek Coder V2</option>
                     <option value="llama3">Llama 3</option>
                     <option value="mistral">Mistral</option>
                 </select>
                 <select id="voiceSelector" class="control-item">
                     <option value="default" selected>Default</option>
                 </select>
                 <div class="tts-switch">
                      <input type="checkbox" id="ttsToggle">
                      <label for="ttsToggle" title="Enable/Disable Speech Output"></label>
                 </div>
                 <button id="clearChatButton" class="control-item" title="Clear Chat History">C</button>
            </div>
            <button id="stopGeneratingButton" class="control-item" title="Stop Current Response">Stop</button>
        </div>

        <!-- System info -->
        <div id="systemInfo">Status: Ready</div>
    </div>

    <script> // No type="module"
        'use strict';
        try {
            // --- References ---
            const bgCanvas = document.getElementById('particleCanvas'); const orbCanvas = document.getElementById('orbParticleCanvas'); const orbShapeDiv = document.getElementById('orbShapeDiv'); const questionInput = document.getElementById('questionInput'); const inputArea = document.getElementById('inputArea'); const chatDisplayArea = document.getElementById('chatDisplayArea'); const systemInfo = document.getElementById('systemInfo');
            const modelSelector = document.getElementById('modelSelector'); const voiceSelector = document.getElementById('voiceSelector'); const ttsToggle = document.getElementById('ttsToggle'); const clearChatButton = document.getElementById('clearChatButton'); const stopGeneratingButton = document.getElementById('stopGeneratingButton');
            const inputControlGroup = document.getElementById('inputControlGroup');
            if (!bgCanvas || !orbCanvas || !orbShapeDiv || !questionInput || !inputArea || !chatDisplayArea || !systemInfo || !modelSelector || !voiceSelector || !ttsToggle || !clearChatButton || !stopGeneratingButton || !inputControlGroup) { throw new Error("HTML elements missing."); }
            const bgCtx = bgCanvas.getContext('2d'); const orbCtx = orbCanvas.getContext('2d');

            // --- State ---
            let bgAnimationFrameId = null; let orbAnimationFrameId = null; let isShaking = false; let thinkingFlag = false; let isGeneratingStream = false; let isSpeaking = false; let targetOrbHue = 0; let globalBgHue = 0; let orbAgitation = 0;
            let chatHistory = []; let thinkingMessageElement = null; let currentAbortController = null;
            let isTtsEnabled = false; let selectedModel = modelSelector.value;
            let availableVoices = []; let selectedVoice = null;
            const MAX_CONTEXT_TURNS = 3;

            // --- Voice List Population (Filter Irvin) ---
            function populateVoiceList() { if (!('speechSynthesis' in window)) return; availableVoices = window.speechSynthesis.getVoices(); voiceSelector.innerHTML = '<option value="default" selected>Default</option>'; const maleNames = /male|david|mark|guy|man|tom/i; const femaleNames = /female|zira|susan|hazel|woman|linda|kim/i; const irvinName = /irvin/i; availableVoices.forEach((voice, index) => { if (voice.lang.startsWith('en-') && !irvinName.test(voice.name)) { const option = document.createElement('option'); option.value = index; let displayName = voice.name; if (maleNames.test(voice.name)) displayName += " (M)"; else if (femaleNames.test(voice.name)) displayName += " (F)"; option.textContent = displayName; voiceSelector.appendChild(option); } }); console.log("Voices populated (Irvin filtered):", voiceSelector.options.length - 1); if (selectedVoice) { const previouslySelectedIndex = availableVoices.findIndex(v => v.name === selectedVoice.name); if (previouslySelectedIndex !== -1 && !irvinName.test(availableVoices[previouslySelectedIndex].name)) { voiceSelector.value = previouslySelectedIndex; } else { selectedVoice = null; voiceSelector.value = "default"; } } else { voiceSelector.value = "default"; } }

            // --- Particle Systems & Resize ---
            let bgParticlesArray = []; const bgNumberOfParticles = 70; function setupBgCanvas() { if(!bgCanvas) return; bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight; } class BgParticle { constructor() { this.x = Math.random() * bgCanvas.width; this.y = Math.random() * bgCanvas.height; this.size = Math.random() * 2 + 0.5; this.speedX = Math.random() * 1 - 0.5; this.speedY = Math.random() * 1 - 0.5; this.saturation = 50 + Math.random() * 30; this.lightness = 70 + Math.random() * 20; this.alpha = Math.random() * 0.4 + 0.1; } draw() { if(!bgCtx) return; const currentHue = globalBgHue; bgCtx.fillStyle = `hsla(${currentHue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha})`; bgCtx.shadowBlur = 4; bgCtx.shadowColor = `hsla(${currentHue}, ${this.saturation}%, ${this.lightness}%, 0.4)`; bgCtx.beginPath(); bgCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2); bgCtx.fill(); bgCtx.shadowBlur = 0;} update() { this.x += this.speedX; this.y += this.speedY; if (this.x < 0 || this.x > bgCanvas.width) { this.speedX *= -1; this.x += this.speedX; if (this.x < 0) this.x = 0; if (this.x > bgCanvas.width) this.x = bgCanvas.width; } if (this.y < 0 || this.y > bgCanvas.height) { this.speedY *= -1; this.y += this.speedY; if (this.y < 0) this.y = 0; if (this.y > bgCanvas.height) this.y = bgCanvas.height; } this.alpha += (Math.random() - 0.5) * 0.04; if (this.alpha < 0.1) this.alpha = 0.1; if (this.alpha > 0.5) this.alpha = 0.5;} } function initBgParticles() { bgParticlesArray = []; if (bgCanvas && bgCanvas.width > 0) { for (let i = 0; i < bgNumberOfParticles; i++) bgParticlesArray.push(new BgParticle()); } }
            function animateBgParticles() { if (!bgCtx || bgParticlesArray.length === 0) return; bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height); globalBgHue = (globalBgHue + 1.8) % 360; bgParticlesArray.forEach(p => { p.update(); p.draw(); }); bgAnimationFrameId = requestAnimationFrame(animateBgParticles); }

            // Orb Particle System (Multi-Mode Physics)
            // (OrbParticle class and initOrbParticles remain the same)
            let orbParticlesArray = []; const orbNumberOfParticles = 50;
            function setupOrbCanvas() { if (!orbShapeDiv || !orbCanvas) return; orbCanvas.width = orbShapeDiv.clientWidth; orbCanvas.height = orbShapeDiv.clientHeight; }
            class OrbParticle { constructor() { const radius = orbCanvas.width / 2; this.x = radius + (Math.random() - 0.5) * radius * 0.8; this.y = radius + (Math.random() - 0.5) * radius * 0.8; this.size = Math.random() * 1.5 + 0.6; this.baseSpeedX = (Math.random() - 0.5) * 0.2; this.baseSpeedY = (Math.random() - 0.5) * 0.2; this.speedX = this.baseSpeedX; this.speedY = this.baseSpeedY; this.hue = Math.random() * 360; this.saturation = 85 + Math.random() * 15; this.lightness = 65 + Math.random() * 15; this.alpha = Math.random() * 0.5 + 0.2; this.targetY = this.y; } draw() { if(!orbCtx) return; const effectiveLightness = this.lightness + (isSpeaking ? Math.sin(Date.now() / 80 + this.x / 10) * 6 : 0); orbCtx.fillStyle = `hsla(${this.hue}, ${this.saturation}%, ${effectiveLightness}%, ${this.alpha})`; orbCtx.shadowBlur = isSpeaking ? 4 : 3; orbCtx.shadowColor = `hsla(${this.hue}, ${this.saturation}%, ${effectiveLightness}%, 0.5)`; orbCtx.beginPath(); orbCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2); orbCtx.fill(); orbCtx.shadowBlur = 0; } update() { const centerX = orbCanvas.width / 2; const centerY = orbCanvas.height / 2; const boundaryRadius = centerX - this.size; let hueDiff = targetOrbHue - this.hue; if (hueDiff > 180) hueDiff -= 360; if (hueDiff < -180) hueDiff += 360; this.hue += hueDiff * 0.05; if (this.hue < 0) this.hue += 360; if (this.hue >= 360) this.hue -= 360; let targetSpeedX = 0; let targetSpeedY = 0; let reflectionDamping = 0.85; if (isSpeaking) { reflectionDamping = 0.9; const waveFrequency = 0.08; const waveAmplitude = centerY * 0.35; const waveSpeed = 0.003; const wavePullStrength = 0.08; this.targetY = centerY + Math.sin(this.x * waveFrequency + Date.now() * waveSpeed) * waveAmplitude; targetSpeedY = (this.targetY - this.y) * wavePullStrength; targetSpeedX = this.speedX * 0.9 + (Math.random() - 0.5) * 0.5; } else if (isShaking) { reflectionDamping = 0.95; const currentAgitation = orbAgitation; const pullStrength = 0.05; const tangentialSpeedBase = 0.4 + currentAgitation * 0.8; const dx = this.x - centerX; const dy = this.y - centerY; const distance = Math.sqrt(dx * dx + dy * dy) + 0.001; const normalX = dx / distance; const normalY = dy / distance; const tx = -normalY; const ty = normalX; const radialError = boundaryRadius - distance; const pullForceX = normalX * radialError * pullStrength; const pullForceY = normalY * radialError * pullStrength; targetSpeedX = tx * tangentialSpeedBase + pullForceX; targetSpeedY = ty * tangentialSpeedBase + pullForceY; } else { reflectionDamping = 0.85; targetSpeedX = this.baseSpeedX; targetSpeedY = this.baseSpeedY; const centerPull = 0.01; targetSpeedX -= (this.x - centerX) * centerPull * 0.01; targetSpeedY -= (this.y - centerY) * centerPull * 0.01; } const interpolationFactor = 0.1; this.speedX += (targetSpeedX - this.speedX) * interpolationFactor; this.speedY += (targetSpeedY - this.speedY) * interpolationFactor; this.x += this.speedX; this.y += this.speedY; const dx_pos = this.x - centerX; const dy_pos = this.y - centerY; const distanceSq = dx_pos * dx_pos + dy_pos * dy_pos; if (distanceSq > boundaryRadius * boundaryRadius) { const distance = Math.sqrt(distanceSq); const normalX = dx_pos / distance; const normalY = dy_pos / distance; this.x = centerX + normalX * boundaryRadius; this.y = centerY + normalY * boundaryRadius; const dotProduct = this.speedX * normalX + this.speedY * normalY; this.speedX = (this.speedX - (1 + reflectionDamping) * dotProduct * normalX); this.speedY = (this.speedY - (1 + reflectionDamping) * dotProduct * normalY); if (isSpeaking) { this.targetY = this.y; } } this.alpha += (Math.random() - 0.5) * 0.05; if (this.alpha < 0.15) this.alpha = 0.15; if (this.alpha > 0.85) this.alpha = 0.85; } }
            function initOrbParticles() { orbParticlesArray = []; if (orbCanvas && orbCanvas.width > 0) { for (let i = 0; i < orbNumberOfParticles; i++) orbParticlesArray.push(new OrbParticle()); } }
            // (animateOrb remains the same)
            function animateOrb() { if (!orbCtx) return; orbCtx.clearRect(0, 0, orbCanvas.width, orbCanvas.height); if (!isSpeaking && isShaking) { if (orbAgitation < 1) { orbAgitation = Math.min(1, orbAgitation + 0.02); } } else if (!isSpeaking && !isShaking) { if (orbAgitation > 0) { orbAgitation = Math.max(0, orbAgitation - 0.03); } } if (orbParticlesArray.length > 0) { orbParticlesArray.forEach(p => { p.update(); p.draw(); }); } orbAnimationFrameId = requestAnimationFrame(animateOrb); }
            // (handleResize remains the same)
            function handleResize() { console.log("Window resizing..."); if (bgAnimationFrameId) cancelAnimationFrame(bgAnimationFrameId); if (orbAnimationFrameId) cancelAnimationFrame(orbAnimationFrameId); setupBgCanvas(); setupOrbCanvas(); initBgParticles(); initOrbParticles(); animateBgParticles(); animateOrb(); } window.addEventListener('resize', handleResize);

            // --- Function to toggle input controls ---
            // (showInputControls remains the same)
            function showInputControls(show) { if (inputControlGroup && stopGeneratingButton) { inputControlGroup.style.display = show ? 'flex' : 'none'; stopGeneratingButton.style.display = show ? 'none' : 'inline-flex'; } }

            // --- Interaction Logic (Ollama) ---
            // (askQuestion, finalizeOrbiResponse remain the same)
            async function askQuestion() { console.log("ASK: Attempting. thinkingFlag:", thinkingFlag); if (thinkingFlag) { console.log("ASK: Blocked by thinkingFlag."); return; } const question = questionInput.value.trim(); if (!question) { return; } window.speechSynthesis.cancel(); isSpeaking = false; orbAgitation = 0; console.log("ASK: Sending to Ollama. Model:", selectedModel); thinkingFlag = true; isShaking = true; isGeneratingStream = true; questionInput.disabled = true; showInputControls(false); displayMessage(question, true); thinkingMessageElement = displayMessage("...consults...", false, true); questionInput.value = ''; let promptContext = ""; const relevantHistory = chatHistory.slice(-MAX_CONTEXT_TURNS); if (relevantHistory.length > 0) { promptContext = "Conversation History:\n"; relevantHistory.forEach(turn => { promptContext += `User: ${turn.question}\nOrbi: ${turn.answer}\n`; }); promptContext += "\n---\nCurrent Interaction:\n"; } const ollamaUrl = 'http://localhost:11434/api/generate'; const prompt = `${promptContext}User Query:\n${question}\n\nOrbi's concise response:`; currentAbortController = new AbortController(); let accumulatedResponse = ""; try { console.log(`ASK: Fetching stream...`); const response = await fetch(ollamaUrl, { method: 'POST', mode: 'cors', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ model: selectedModel, prompt: prompt, stream: true }), signal: currentAbortController.signal }); if (!response.ok) { throw new Error(`Ollama Connection Error! Status: ${response.status}`); } if (!response.body) { throw new Error("Response body is missing"); } const reader = response.body.getReader(); const decoder = new TextDecoder(); let partialLine = ""; while (true) { const { value, done } = await reader.read(); if (done) { console.log("ASK: Stream finished."); isGeneratingStream = false; break; } const chunk = decoder.decode(value, { stream: true }); const lines = (partialLine + chunk).split('\n'); partialLine = lines.pop() || ""; lines.forEach(line => { if (line.trim() === "") return; try { const parsed = JSON.parse(line); if (parsed.response) { accumulatedResponse += parsed.response; updateOrbiMessage(thinkingMessageElement, accumulatedResponse); } if (parsed.done) { console.log("ASK: Stream reported done via JSON."); isGeneratingStream = false; } } catch (e) { console.warn("ASK: Failed to parse stream line JSON:", line, e); } }); } finalizeOrbiResponse(thinkingMessageElement, accumulatedResponse, question); } catch (error) { isGeneratingStream = false; console.error("ASK: Error during fetch or streaming:", error); let errorMsg; if (error.name === 'AbortError') { errorMsg = "Generation stopped by user."; console.log("ASK: Generation aborted."); } else if (error instanceof TypeError && error.message.includes('Failed to fetch')) { errorMsg = `Network Error: Could not reach Orbi's core (Ollama) at ${ollamaUrl}. Is Ollama running?`; } else { errorMsg = `Error communicating with Orbi's core.\nDetails: ${error.message}`; } finalizeOrbiResponse(thinkingMessageElement, errorMsg, question, true); } finally { console.log("ASK: Request finally block."); isShaking = false; thinkingFlag = false; questionInput.disabled = false; currentAbortController = null; thinkingMessageElement = null; if (!document.hidden) { questionInput.focus(); } console.log("ASK: State after request: thinkingFlag:", thinkingFlag, "isGeneratingStream:", isGeneratingStream); if (!isTtsEnabled || isGeneratingStream || !isSpeaking) { showInputControls(true); orbAgitation = 0; } } }
            function finalizeOrbiResponse(element, finalText, question, isError = false) { if (element) { element.className = 'orbi-message'; if (isError) { element.innerHTML = `<span class="message-label">Orbi:</span><i>${escapeHtml(finalText).replace(/\n/g, '<br>')}</i>`; } else { updateOrbiMessage(element, finalText); if (!element.parentNode.querySelector('.copy-button')) { const copyBtn = document.createElement('button'); copyBtn.className = 'copy-button'; copyBtn.innerHTML = 'ðŸ“‹'; copyBtn.title = 'Copy response'; copyBtn.onclick = (e) => { const labelSpan = element.querySelector('.message-label'); const responseText = labelSpan ? element.textContent.substring(labelSpan.textContent.length).trim() : element.textContent.trim(); navigator.clipboard.writeText(responseText).then(() => { copyBtn.innerHTML = 'âœ”ï¸'; copyBtn.classList.add('copied'); setTimeout(() => { copyBtn.innerHTML = 'ðŸ“‹'; copyBtn.classList.remove('copied'); }, 1000); }).catch(err => { console.error('Failed to copy: ', err); copyBtn.innerHTML = 'âŒ'; setTimeout(() => { copyBtn.innerHTML = 'ðŸ“‹'; }, 1000); }); }; element.parentNode.appendChild(copyBtn); } } } if (!isError || true) { chatHistory.push({ timestamp: new Date(), question: question, answer: finalText }); console.log("HISTORY: Added final entry. Length:", chatHistory.length); } const shouldSpeak = isTtsEnabled && !isError && finalText.trim().length > 0; if (shouldSpeak) { speakText(finalText); } else { isShaking = false; orbAgitation = 0; showInputControls(true); } }


            // --- Display Logic ---
            // (displayMessage, updateOrbiMessage remain the same)
            function displayMessage(text, isUser, isThinking = false) { const messagePairDiv = document.createElement('div'); messagePairDiv.className = 'message-pair'; let messageElement; if (isUser) { messageElement = document.createElement('p'); messageElement.className = 'user-message'; messageElement.innerHTML = `<span class="message-label">You:</span>${escapeHtml(text)}`; messagePairDiv.appendChild(messageElement); } else { messageElement = document.createElement('p'); messageElement.className = isThinking ? 'thinking-message' : 'orbi-message'; messageElement.innerHTML = `<span class="message-label">Orbi:</span>${isThinking ? escapeHtml(text) : escapeHtml(text).replace(/\n/g, '<br>')}`; messagePairDiv.appendChild(messageElement); if (!isThinking) { const copyBtn = document.createElement('button'); copyBtn.className = 'copy-button'; copyBtn.innerHTML = 'ðŸ“‹'; copyBtn.title = 'Copy response'; copyBtn.onclick = (e) => { const labelSpan = messageElement.querySelector('.message-label'); const responseText = labelSpan ? element.textContent.substring(labelSpan.textContent.length).trim() : element.textContent.trim(); navigator.clipboard.writeText(responseText) .then(() => { copyBtn.innerHTML = 'âœ”ï¸'; copyBtn.classList.add('copied'); console.log("Copied to clipboard:", responseText.substring(0,50)+"..."); setTimeout(() => { copyBtn.innerHTML = 'ðŸ“‹'; copyBtn.classList.remove('copied'); }, 1000); }) .catch(err => { console.error('Failed to copy text: ', err); copyBtn.innerHTML = 'âŒ'; setTimeout(() => { copyBtn.innerHTML = 'ðŸ“‹'; }, 1000); }); }; messagePairDiv.appendChild(copyBtn); } } chatDisplayArea.prepend(messagePairDiv); chatDisplayArea.scrollTop = 0; return isUser ? null : messageElement; }
            function updateOrbiMessage(element, newText) { if (element) { element.innerHTML = `<span class="message-label">Orbi:</span>${escapeHtml(newText).replace(/\n/g, '<br>')}`; } }

             // --- TTS Function ---
            // (speakText remains the same)
             function speakText(text) { if (!('speechSynthesis' in window) || availableVoices.length === 0 || text.trim().length === 0) { console.warn("Speech synthesis not supported, no voices, or empty text."); isSpeaking = false; isShaking = false; orbAgitation = 0; showInputControls(true); return; } window.speechSynthesis.cancel(); isSpeaking = false; orbAgitation = 0; const utterance = new SpeechSynthesisUtterance(text); utterance.lang = 'en-US'; utterance.rate = 1.0; utterance.pitch = 1.0; if (selectedVoice) { utterance.voice = selectedVoice; console.log("Using voice:", selectedVoice.name); } else { console.log("Using default voice."); } utterance.onstart = () => { console.log("TTS started."); isSpeaking = true; isShaking = false; orbAgitation = 0; }; utterance.onend = () => { console.log("TTS finished."); isSpeaking = false; showInputControls(true); }; utterance.onerror = (event) => { console.error("TTS error:", event.error); isSpeaking = false; isShaking = false; orbAgitation = 0; showInputControls(true); }; window.speechSynthesis.speak(utterance); }

             // --- HTML Escaping Helper ---
             function escapeHtml(unsafe) { if (typeof unsafe !== 'string') return unsafe; return unsafe .replace(/&/g, "&amp;") .replace(/</g, "&lt;") .replace(/>/g, "&gt;") .replace(/"/g, "&quot;") .replace(/'/g, "&#039;"); }

             // --- Save/Download Helpers ---
             // (triggerTextFileDownload, saveSessionLogOnUnload remain the same)
             function triggerTextFileDownload(content, filename) { try {const blob = new Blob([content], { type: 'text/plain;charset=utf-8' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(link.href); console.log(`DOWNLOAD: Triggered download for: ${filename}`);} catch (error) {console.error(`DOWNLOAD: Error triggering download for ${filename}:`, error);} }
             function saveSessionLogOnUnload(event) { console.log("UNLOAD: beforeunload event triggered."); if (chatHistory.length === 0) { return; } console.log(`UNLOAD: Preparing to save ${chatHistory.length} chat entries.`); let logContent = `--- Orbi Session Log ---\nModel Used: ${selectedModel}\nSession End: ${new Date().toLocaleString()}\n\n`; chatHistory.forEach((entry, index) => { logContent += `--- Entry ${index + 1} ---\nTimestamp: ${entry.timestamp.toLocaleString()}\nQuestion:\n${entry.question}\n\nAnswer:\n${entry.answer}\n--------------------\n\n`; }); logContent += "--- End Session Log ---"; const timestamp = new Date(); const YYYY = timestamp.getFullYear(); const MM = String(timestamp.getMonth() + 1).padStart(2, '0'); const DD = String(timestamp.getDate()).padStart(2, '0'); const hh = String(timestamp.getHours()).padStart(2, '0'); const mm = String(timestamp.getMinutes()).padStart(2, '0'); const ss = String(timestamp.getSeconds()).padStart(2, '0'); const filename = `Orbi_Session_Log_${YYYY}${MM}${DD}_${hh}${mm}${ss}.txt`; triggerTextFileDownload(logContent, filename); }


            // --- Event Listeners Setup ---
            // (setupEventListeners remains the same - orb click handler removed)
             function setupEventListeners() { orbShapeDiv.addEventListener('mousemove', (event) => { const rect = orbShapeDiv.getBoundingClientRect(); const centerX = rect.left + rect.width / 2; const centerY = rect.top + rect.height / 2; const mouseX = event.clientX; const mouseY = event.clientY; const deltaX = mouseX - centerX; const deltaY = mouseY - centerY; let angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI); angle = (angle + 360 + 180) % 360; targetOrbHue = angle; }); questionInput.addEventListener('keypress', function (e) { if (e.key === 'Enter' && !e.shiftKey && !thinkingFlag) { e.preventDefault(); askQuestion(); } }); questionInput.addEventListener('focus', () => { questionInput.style.borderColor = '#888'; }); questionInput.addEventListener('blur', () => { questionInput.style.borderColor = '#555'; }); modelSelector.addEventListener('change', (e) => { selectedModel = e.target.value; console.log("Model selected:", selectedModel); }); voiceSelector.addEventListener('change', (e) => { const selectedIndex = e.target.value; if (selectedIndex === "default" || !availableVoices[selectedIndex] || !voiceSelector.options[voiceSelector.selectedIndex]) { selectedVoice = null; console.log("Voice selected: Default"); } else { selectedVoice = availableVoices[selectedIndex]; console.log("Voice selected:", selectedVoice ? selectedVoice.name : 'Error finding voice'); } }); ttsToggle.addEventListener('change', (e) => { isTtsEnabled = e.target.checked; console.log("TTS enabled:", isTtsEnabled); if (!isTtsEnabled) { window.speechSynthesis.cancel(); isSpeaking = false; isShaking = false; orbAgitation = 0; showInputControls(true); } }); clearChatButton.addEventListener('click', () => { if (confirm("Are you sure you want to clear the chat history?")) { chatHistory = []; chatDisplayArea.innerHTML = ''; window.speechSynthesis.cancel(); isSpeaking = false; isShaking = false; orbAgitation = 0; showInputControls(true); console.log("Chat cleared."); } }); stopGeneratingButton.addEventListener('click', () => { if (currentAbortController) { console.log("Stop button clicked. Aborting request..."); currentAbortController.abort(); } }); window.addEventListener('beforeunload', saveSessionLogOnUnload); if (speechSynthesis.onvoiceschanged !== undefined) { speechSynthesis.onvoiceschanged = populateVoiceList; } console.log("Event listeners attached."); }

            // --- Initial Setup ---
            // (initializeOrb remains the same)
             function initializeOrb() { console.log("Initializing Orbi (Ollama Advanced)..."); systemInfo.innerHTML = "Status: Ready"; chatDisplayArea.innerHTML = ''; showInputControls(true); if (!('speechSynthesis' in window)) { ttsToggle.disabled = true; voiceSelector.disabled = true; const label = document.querySelector('label[for="ttsToggle"]'); if(label) label.title = "Speech synthesis not supported"; if(label) label.style.opacity = "0.5"; console.warn("TTS Not Supported."); } else { window.speechSynthesis.cancel(); isSpeaking = false; populateVoiceList(); } setupBgCanvas(); initBgParticles(); animateBgParticles(); setupOrbCanvas(); initOrbParticles(); animateOrb(); setupEventListeners(); setTimeout(() => { if (systemInfo) systemInfo.style.opacity = '0'; }, 30000); console.log("Orbi Initialized."); questionInput.focus(); }
            initializeOrb(); // Start everything

        } catch (error) {
             console.error("Fatal Error Initializing Orbi:", error); const errInfo = document.getElementById('systemInfo'); const errDisplay = errInfo || document.body; errDisplay.innerHTML = `<p style="color:red; padding: 20px; font-size: 1.2em;">Oops! Orbi encountered a critical error during initialization. Please check the console (F12) for details.</p><pre style="color:red; white-space: pre-wrap;">${error.stack}</pre>`; const container = document.querySelector('.container'); if(container) container.style.display = 'none';
        }
    </script>

</body>
</html>