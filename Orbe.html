<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbe 1.2 (Complete & Cleaned)</title>

    <!-- Howler.js for Audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
    <!-- Prism CSS for Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" />
    <!-- Feather Icons Script -->
    <script defer src="https://unpkg.com/feather-icons"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; } html, body { height: 100%; overflow: hidden; } body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #000000; color: #ffffff; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 10px; position: relative; } body.modal-open { overflow: hidden; } #particleCanvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; pointer-events: none; }
        .container { text-align: center; padding: 0; border-radius: 15px; max-width: 95%; width: 960px; position: relative; z-index: 1; display: flex; flex-direction: column; height: calc(100vh - 40px); background-color: #111; border: 1px solid #333; box-shadow: 0 5px 20px rgba(0,0,0,0.7); overflow: hidden; }
        .control-item { font-size: 0.8rem; padding: 0 8px; border-radius: 6px; border: 1px solid #383838; background-image: linear-gradient(to bottom,rgba(180,180,180,0.1) 0%,rgba(140,140,140,0.08) 15%,rgba(100,100,100,0.08) 40%,rgba(70,70,70,0.15) 70%,rgba(50,50,50,0.2) 90%,rgba(35,35,35,0.3) 100%), linear-gradient(to bottom, #5a5a5a, #383838); background-color: #444; color: #ddd; cursor: pointer; transition: background-image 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease; height: 28px; display: inline-flex; align-items: center; justify-content: center; vertical-align: middle; box-sizing: border-box; flex-shrink: 0; min-width: 30px; box-shadow: 0 1px 1px rgba(0,0,0,0.5), inset 0 1px 0px rgba(255,255,255,0.06); text-shadow: 0 1px 1px rgba(0,0,0,0.6); gap: 5px; }
        .control-item:hover { border-color: #555; background-image: linear-gradient(to bottom,rgba(190,190,190,0.12) 0%,rgba(150,150,150,0.1) 15%,rgba(110,110,110,0.1) 40%,rgba(80,80,80,0.18) 70%,rgba(60,60,60,0.25) 90%,rgba(45,45,45,0.35) 100%), linear-gradient(to bottom, #6a6a6a, #484848); box-shadow: 0 2px 2px rgba(0,0,0,0.6), inset 0 1px 0px rgba(255,255,255,0.08); }
        .control-item:active { background-image: linear-gradient(to top,rgba(180,180,180,0.08) 0%,rgba(140,140,140,0.06) 15%,rgba(100,100,100,0.06) 40%,rgba(70,70,70,0.12) 70%,rgba(50,50,50,0.18) 90%,rgba(35,35,35,0.25) 100%), linear-gradient(to top, #5a5a5a, #383838); box-shadow: inset 0 1px 3px rgba(0,0,0,0.5); text-shadow: none; }
        .control-item:focus { outline: none; border-color: #777; box-shadow: 0 1px 1px rgba(0,0,0,0.5), inset 0 0 0 1px rgba(150, 150, 150, 0.4), inset 0 1px 0px rgba(255,255,255,0.06); }
        textarea#questionInput { flex-grow: 1; padding: 8px 12px; border: 1px solid #555; border-radius: 8px; font-size: 0.9rem; background-color: #252525; color: #ffffff; box-shadow: inset 0 1px 3px rgba(0,0,0,0.4); margin: 0; line-height: 1.4; max-height: 100px; resize: none; height: 32px; box-sizing: border-box; overflow-y: auto; font-family: inherit; }
        textarea#questionInput:focus { outline: none; border-color: #888; box-shadow: inset 0 1px 3px rgba(0,0,0,0.4), 0 0 0 2px rgba(80, 80, 80, 0.3); }
        textarea#questionInput::placeholder { color: #aaa; opacity: 0.8; }
        .control-item:disabled { opacity: 0.6; cursor: not-allowed; background-image: linear-gradient(to bottom, #4a4a4a, #2f2f2f); border-color: #2f2f2f; box-shadow: inset 0 1px 2px rgba(0,0,0,0.4); text-shadow: none; }
        .control-item svg.feather { width: 14px; height: 14px; vertical-align: middle; stroke-width: 1.8; color: #ccc; }
        .control-item:hover svg.feather { color: #fff; }
        .control-item span + svg.feather, .control-item svg.feather + span { margin-left: 0; margin-right: 0; }
        select.control-item { padding-left: 8px; padding-right: 20px; justify-content: flex-start; -webkit-appearance: none; -moz-appearance: none; appearance: none; background-position: right 6px center; background-repeat: no-repeat; background-size: 8px 8px; background-image: linear-gradient(to bottom,rgba(180,180,180,0.1) 0%,rgba(140,140,140,0.08) 15%,rgba(100,100,100,0.08) 40%,rgba(70,70,70,0.15) 70%,rgba(50,50,50,0.2) 90%,rgba(35,35,35,0.3) 100%), linear-gradient(to bottom, #5a5a5a, #383838), url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 80 80'%3E%3Cpath d='M.75 16.75l38.5 38.5 38.5-38.5z' fill='%23dddddd'/%3E%3C/svg%3E"); }
        select#modelSelector.control-item { min-width: 100px; max-width: 180px; }
        select#modeSelector.control-item { min-width: 100px; max-width: 160px; }
        select#presetSelector.control-item { min-width: 100px; max-width: 160px; }
        select.control-item:hover { background-image: linear-gradient(to bottom,rgba(190,190,190,0.12) 0%,rgba(150,150,150,0.1) 15%,rgba(110,110,110,0.1) 40%,rgba(80,80,80,0.18) 70%,rgba(60,60,60,0.25) 90%,rgba(45,45,45,0.35) 100%), linear-gradient(to bottom, #6a6a6a, #484848), url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 80 80'%3E%3Cpath d='M.75 16.75l38.5 38.5 38.5-38.5z' fill='%23ffffff'/%3E%3C/svg%3E"); }
        button.control-item { padding: 0 8px; }
        #stopGeneratingButton { border: 1px solid #a00; background-image: linear-gradient(to bottom,rgba(255,100,100,0.12) 0%,rgba(200,80,80,0.1) 15%,rgba(160,60,60,0.1) 40%,rgba(130,40,40,0.2) 70%,rgba(110,20,20,0.3) 90%,rgba(90,0,0,0.4) 100%), linear-gradient(to bottom, #a33, #800); display: none; color: #fcc; margin-left: 5px; }
        #stopGeneratingButton:hover { border-color: #c00; background-image: linear-gradient(to bottom,rgba(255,120,120,0.15) 0%,rgba(210,100,100,0.12) 15%,rgba(170,80,80,0.12) 40%,rgba(140,60,60,0.25) 70%,rgba(120,40,40,0.35) 90%,rgba(100,20,20,0.45) 100%), linear-gradient(to bottom, #b44, #911); }
        #stopGeneratingButton:active { background-image: linear-gradient(to top,rgba(255,100,100,0.1) 0%,rgba(200,80,80,0.08) 15%,rgba(160,60,60,0.08) 40%,rgba(130,40,40,0.18) 70%,rgba(110,20,20,0.28) 90%,rgba(90,0,0,0.38) 100%), linear-gradient(to top, #a33, #800); box-shadow: inset 0 1px 3px rgba(0,0,0,0.5); }
        #playPauseButton.tts-playing { background-image: linear-gradient(to bottom,rgba(180,210,255,0.1) 0%,rgba(140,180,230,0.08) 15%,rgba(100,150,210,0.08) 40%,rgba(70,120,190,0.15) 70%,rgba(50,100,170,0.2) 90%,rgba(35,80,150,0.3) 100%), linear-gradient(to bottom, #68b, #469); border-color: #57a; color: #eff; }
        #playPauseButton.tts-playing:hover { background-image: linear-gradient(to bottom,rgba(190,220,255,0.12) 0%,rgba(150,190,240,0.1) 15%,rgba(110,160,220,0.1) 40%,rgba(80,130,200,0.18) 70%,rgba(60,110,180,0.25) 90%,rgba(45,90,160,0.35) 100%), linear-gradient(to bottom, #79c, #57a); border-color: #68b; }
        #playPauseButton, #fastForwardButton { display: none; }
        #playPauseButton svg.feather { vertical-align: middle; }
        #fastForwardButton .rate-display { font-size: 0.75em; margin-left: 4px; color: #ccc; font-weight: normal; }
        #ttsToggleButton { min-width: 75px; justify-content: center; }
        #ttsToggleButton span { margin-left: 4px; }
        #ttsToggleButton.tts-enabled { background-image: linear-gradient(to bottom,rgba(180,220,180,0.1) 0%,rgba(140,190,140,0.08) 15%,rgba(100,160,100,0.08) 40%,rgba(70,130,70,0.15) 70%,rgba(50,110,50,0.2) 90%,rgba(35,90,35,0.3) 100%), linear-gradient(to bottom, #6a6, #484); border-color: #595; color: #efe; }
        #ttsToggleButton.tts-enabled:hover { background-image: linear-gradient(to bottom,rgba(190,230,190,0.12) 0%,rgba(150,200,150,0.1) 15%,rgba(110,170,110,0.1) 40%,rgba(80,140,80,0.18) 70%,rgba(60,120,60,0.25) 90%,rgba(45,100,45,0.35) 100%), linear-gradient(to bottom, #7b7, #595); border-color: #6a6; }
        #micButton.listening { background-image: linear-gradient(to bottom,rgba(180,210,255,0.15) 0%,rgba(140,180,230,0.12) 15%,rgba(100,150,210,0.12) 40%,rgba(70,120,190,0.2) 70%,rgba(50,100,170,0.25) 90%,rgba(35,80,150,0.35) 100%), linear-gradient(to bottom, #79c, #57a); border-color: #68b; box-shadow: 0 0 8px rgba(80, 160, 220, 0.5), inset 0 1px 1px rgba(0,0,0,0.4); }
        #micButton.listening:hover { background-image: linear-gradient(to bottom,rgba(190,220,255,0.18) 0%,rgba(150,190,240,0.15) 15%,rgba(110,160,220,0.15) 40%,rgba(80,130,200,0.23) 70%,rgba(60,110,180,0.30) 90%,rgba(45,90,160,0.40) 100%), linear-gradient(to bottom, #8ac, #68b); border-color: #79c; }
        .orb-shape-container { position: relative; width: 90px; height: 90px; margin: 15px auto 10px auto; cursor: default; z-index: 4; flex-shrink: 0; align-self: center; }
        .orb-shape { width: 100%; height: 100%; border-radius: 50%; border: 2px solid #aaa; position: relative; z-index: 1; box-shadow: 0 4px 12px rgba(0,0,0,0.5), inset 0 2px 4px rgba(0,0,0,0.4); overflow: hidden; background-color: transparent; }
        #orbParticleCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%; pointer-events: none; z-index: 0; }
        .input-area { width: 100%; padding: 8px 15px; margin: 0; display: flex; flex-direction: column; gap: 6px; background-color: rgba(26, 26, 26, 0.8); border-top: 1px solid #333; flex-shrink: 0; z-index: 5; } .input-row { display: flex; width: 100%; gap: 6px; align-items: center; }
        #attachFileButton { margin-left: 0px; margin-right: 5px; }
        #micButton { margin-left: 5px; margin-right: 5px; }
        #attachmentDisplay { display: none; align-items: center; background-color: rgba(60, 60, 60, 0.5); padding: 2px 6px; border-radius: 4px; font-size: 0.75em; color: #ccc; margin-right: 6px; flex-shrink: 0; }
        #attachmentDisplay span { max-width: 150px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-right: 4px; }
        #clearAttachmentButton { background: none; border: none; padding: 0; color: #aaa; cursor: pointer; line-height: 1; }
        #clearAttachmentButton:hover { color: #fff; }
        #clearAttachmentButton svg { width: 12px; height: 12px; vertical-align: middle; }
        #chatDisplayArea { flex-grow: 1; width: 100%; overflow-y: auto; padding: 10px 1%; background-color: rgba(20, 20, 20, 0.08); border: none; display: flex; flex-direction: column; align-items: stretch; scrollbar-width: thin; scrollbar-color: rgba(85, 85, 85, 0.7) rgba(34, 34, 34, 0.5); scroll-behavior: smooth; } #chatDisplayArea::-webkit-scrollbar { width: 8px; } #chatDisplayArea::-webkit-scrollbar-track { background: rgba(34, 34, 34, 0.5); border-radius: 4px; } #chatDisplayArea::-webkit-scrollbar-thumb { background-color: rgba(85, 85, 85, 0.7); border-radius: 4px; } .message-pair { margin-bottom: 15px; max-width: 100%; display: flex; flex-direction: column; }
        .user-message, .orbe-message, .thinking-message { padding: 10px 14px; border-radius: 12px; line-height: 1.6; font-size: 14px; word-wrap: break-word; overflow-wrap: break-word; text-align: left; max-width: 98%; box-shadow: 0 1px 2px rgba(0,0,0,0.5); color: #f0f0f0; position: relative; border: 1px solid #282828; }
        .orbe-message { background-color: rgba(40, 40, 40, 0.6); align-self: flex-start; border-bottom-left-radius: 3px; color: #ffffff; }
        .user-message { background-color: rgba(58, 58, 58, 0.6); align-self: flex-end; border-bottom-right-radius: 3px; } .orbe-message i { color: #ffcccc; font-style: normal; } .thinking-message { background-color: rgba(32, 32, 32, 0.5); color: #bbb; align-self: flex-start; font-style: italic; border-bottom-left-radius: 3px; padding-right: 14px; } .message-label { font-weight: bold; display: block; margin-bottom: 4px; font-size: 0.8em; color: #ccc; } .copy-button { position: absolute; bottom: 5px; right: 8px; width: 24px; height: 24px; background-color: rgba(255, 255, 255, 0.08); border: 1px solid rgba(255, 255, 255, 0.15); color: #bbb; border-radius: 4px; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s ease, background-color 0.2s ease; z-index: 1; } .orbe-message:not(:has(.code-block-wrapper)):hover .copy-button { opacity: 0.7; } .copy-button:hover { opacity: 1; background-color: rgba(255, 255, 255, 0.2); } .copy-button:active { background-color: rgba(255, 255, 255, 0.3); } .copy-button.copied { opacity: 1; background-color: #3a7; color: #fff; } .copy-button svg { width: 12px; height: 12px; stroke: currentColor; }
        .orbe-message strong, .orbe-message b { color: #ffffff; font-weight: bold; }
        .orbe-message h1, .orbe-message h2, .orbe-message h3, .orbe-message h4, .orbe-message h5, .orbe-message h6 { color: #ffffff; font-weight: bold; margin-top: 0.8em; margin-bottom: 0.4em; }
        .orbe-message h1 strong, .orbe-message h1 b, .orbe-message h2 strong, .orbe-message h2 b, .orbe-message h3 strong, .orbe-message h3 b, .orbe-message h4 strong, .orbe-message h4 b, .orbe-message h5 strong, .orbe-message h5 b, .orbe-message h6 strong, .orbe-message h6 b { color: #ffffff; }
        .code-block-wrapper { background-color: transparent; border: 1px solid #444; border-radius: 6px; margin: 10px 0; position: relative; overflow: hidden; padding-top: 25px; } .code-block-wrapper pre[class*="language-"] { margin: 0 !important; padding: 10px 15px 5px 15px !important; background: none !important; border-radius: 0 !important; } .code-block-wrapper code[class*="language-"] { font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important; font-size: 0.85em !important; line-height: 1.5 !important; color: #cdd; white-space: pre !important; } .code-block-wrapper pre { overflow-x: auto; scrollbar-width: thin; scrollbar-color: rgba(85, 85, 85, 0.7) rgba(34, 34, 34, 0.5); } .code-block-wrapper pre::-webkit-scrollbar { height: 8px; width: 8px; } .code-block-wrapper pre::-webkit-scrollbar-track { background: rgba(34, 34, 34, 0.5); border-radius: 4px; } .code-block-wrapper pre::-webkit-scrollbar-thumb { background-color: rgba(85, 85, 85, 0.7); border-radius: 4px; } .code-language-label { position: absolute; top: 4px; left: 8px; font-size: 0.7em; color: #aaa; font-family: sans-serif; text-transform: uppercase; background-color: rgba(40, 40, 40, 0.7); padding: 1px 4px; border-radius: 3px; z-index: 1; } .code-block-actions { display: flex; gap: 4px; justify-content: flex-end; padding: 6px 8px; background-color: rgba(50, 50, 50, 0.6); border-top: 1px solid #444; flex-wrap: wrap; } .code-block-wrapper.editing .code-block-actions { display: none; } .code-block-button { width: 24px; height: 24px; padding: 0; background-color: rgba(80, 80, 80, 0.5); border: 1px solid rgba(120, 120, 120, 0.5); color: #ccc; border-radius: 4px; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; opacity: 0.7; transition: opacity 0.2s ease, background-color 0.2s ease, color 0.2s ease; z-index: 2; } .code-block-wrapper:hover .code-block-button { opacity: 0.9; } .code-block-button:hover { opacity: 1; background-color: rgba(100, 100, 100, 0.7); color: #fff; } .code-block-button:active { background-color: rgba(120, 120, 120, 0.8); } .code-block-button.copied svg, .code-block-button.saved svg { stroke: #fff; } .code-block-button.copied { background-color: #3a7; } .code-block-button.saved { background-color: #a83; }
        .code-block-button.playing-tts { background-color: #39b; border-color: #5bd; box-shadow: 0 0 5px rgba(51, 153, 187, 0.5); }
        .code-block-button svg { width: 13px; height: 13px; stroke: currentColor; vertical-align: middle; } .action-divider { display: inline-block; width: 1px; height: 16px; background-color: rgba(120, 120, 120, 0.5); margin: 0 4px; vertical-align: middle; }
        .inline-editor-container { display: none; padding: 0px 15px 5px 15px; margin-top: -5px; background-color: #1e1e1e; }
        .code-block-wrapper.editing .inline-editor-container { display: block; }
        .code-block-wrapper.editing pre { display: none; }
        .inline-code-textarea { width: 100%; min-height: 80px; max-height: 400px; resize: vertical; background-color: #1e1e1e; color: #d4d4d4; border: 1px solid #444; border-radius: 4px; padding: 8px; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 0.85em; line-height: 1.5; margin-bottom: 5px; box-sizing: border-box; white-space: pre; overflow: auto; tab-size: 4; -moz-tab-size: 4; }
        .inline-editor-actions { display: flex; justify-content: flex-end; gap: 8px; }
        .inline-editor-button { font-size: 0.75rem; padding: 2px 10px; border-radius: 4px; border: 1px solid #555; background-color: #444; color: #eee; cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease; line-height: 1.5; }
        .inline-editor-button:hover { background-color: #555; border-color: #777; }
        .inline-editor-button.save { background-color: #484; border-color: #5a5; }
        .inline-editor-button.save:hover { background-color: #5a5; border-color: #6c6; }
         .inline-editor-button.cancel { background-color: #844; border-color: #a55; }
         .inline-editor-button.cancel:hover { background-color: #a55; border-color: #c66; }
        #snippetsPanel { display: none; position: absolute; bottom: 85px; right: 15px; width: 350px; max-height: 40vh; background-color: rgba(30, 30, 30, 0.95); border: 1px solid #555; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); z-index: 10; overflow-y: auto; padding: 5px; scrollbar-width: thin; scrollbar-color: rgba(85, 85, 85, 0.7) rgba(34, 34, 34, 0.5); } #snippetsPanel::-webkit-scrollbar { width: 8px; } #snippetsPanel::-webkit-scrollbar-track { background: rgba(34, 34, 34, 0.5); border-radius: 4px; } #snippetsPanel::-webkit-scrollbar-thumb { background-color: rgba(85, 85, 85, 0.7); border-radius: 4px; } #snippetsPanel h4 { margin: 5px 10px; font-size: 0.9em; color: #ccc; border-bottom: 1px solid #444; padding-bottom: 3px; } #snippetsList { list-style: none; padding: 0; margin: 0; } #snippetsList li { background-color: rgba(50, 50, 50, 0.5); border-radius: 4px; margin: 4px 0; padding: 6px 8px; font-size: 0.8em; color: #ddd; display: flex; justify-content: space-between; align-items: center; cursor: default; } #snippetsList li:hover { background-color: rgba(65, 65, 65, 0.7); } .snippet-info { flex-grow: 1; margin-right: 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .snippet-lang { font-weight: bold; color: #aaa; margin-right: 5px; text-transform: uppercase; font-size: 0.9em; } .snippet-preview { color: #ccc; } .snippet-actions button { background: none; border: 1px solid #666; color: #bbb; border-radius: 3px; padding: 1px 4px; font-size: 11px; cursor: pointer; margin-left: 4px; transition: background-color 0.2s, color 0.2s; } .snippet-actions button:hover { background-color: #555; color: #fff; } .snippet-actions button.delete:hover { background-color: #a44; border-color: #c66; color: #fff; } .no-snippets { padding: 15px; text-align: center; color: #888; font-style: italic; font-size: 0.9em; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: none; align-items: center; justify-content: center; z-index: 1000; padding: 20px; } .modal-content { background-color: #222; border-radius: 10px; border: 1px solid #555; width: 90%; max-height: 85%; max-width: 1200px; display: flex; flex-direction: column; box-shadow: 0 10px 30px rgba(0,0,0,0.5); overflow: hidden; } #systemPromptModal .modal-content, #modelInfoModal .modal-content { max-height: 85%; } .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 15px; background-color: #333; border-bottom: 1px solid #555; flex-shrink: 0; } .modal-title { font-size: 1em; color: #eee; } .modal-close { background: none; border: none; color: #aaa; font-size: 1.5em; line-height: 1; cursor: pointer; padding: 0 5px; transition: color 0.2s ease; } .modal-close:hover { color: #fff; } .modal-body { flex-grow: 1; padding: 15px; overflow-y: auto; }
        .modal-body pre { background-color: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-size: 0.9em; max-height: 65vh; overflow-y: auto; } #modelInfoBody { padding: 0; } #systemPromptModal .modal-body { padding: 0; } #systemPromptTextarea { width: 100%; height: 100%; min-height: 200px; border: none; outline: none; resize: none; background-color: #1e1e1e; color: #d4d4d4; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 14px; line-height: 1.6; padding: 10px; white-space: pre; overflow: auto; tab-size: 4; -moz-tab-size: 4; } .modal-footer { padding: 8px 15px; text-align: right; background-color: #333; border-top: 1px solid #555; flex-shrink: 0; } .modal-button { font-size: 0.9rem; padding: 5px 15px; border-radius: 5px; border: 1px solid #555; background-color: #666; color: #eee; cursor: pointer; margin-left: 10px; transition: background-color 0.2s ease, border-color 0.2s ease; } .modal-button:hover { background-color: #777; border-color: #888; } .modal-button.save { background-color: #4a4; border-color: #5b5; } .modal-button.save:hover { background-color: #5c5; border-color: #6d6; } .modal-button.cancel { background-color: #944; border-color: #a55; } .modal-button.cancel:hover { background-color: #b55; border-color: #c66; }
        #advancedControls { background-color: rgba(30, 30, 30, 0.8); border-top: 1px solid #333; padding: 0 15px 8px 15px; display: block; }
        #advancedControls details { color: #ccc; border: 1px solid #444; border-radius: 4px; background-color: rgba(40, 40, 40, 0.5); }
        #advancedControls summary { cursor: pointer; padding: 5px 10px; background-color: rgba(60, 60, 60, 0.5); border-radius: 4px; outline: none; font-weight: bold; margin-bottom: 0; display: list-item; list-style: none; }
        #advancedControls summary::marker { content: ""; }
        #advancedControls summary:hover { background-color: rgba(75, 75, 75, 0.5); }
        #advancedControls details[open] summary { border-radius: 4px 4px 0 0; border-bottom: 1px solid #444; }
        .details-content-wrapper { padding: 10px; display: flex; flex-direction: column; gap: 15px; }
        .param-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; }
        .param-control { display: flex; flex-direction: column; gap: 3px; } .param-control label { font-size: 0.75em; color: #bbb; display: flex; justify-content: space-between; align-items: center; }
        .param-control input[type="number"], .param-control input[type="text"], .param-control input[type="password"] { width: 100%; border: 1px solid #555; border-radius: 3px; color: #eee; padding: 2px 4px; font-size: 0.8em; background-color: #252525; }
        .param-control input[type="number"] { -moz-appearance: textfield; }
        .param-control input::-webkit-outer-spin-button, .param-control input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .param-value { font-weight: bold; color: #fff; margin-left: 4px; }
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 18px; background: transparent; cursor: pointer; margin: 5px 0; }
        input[type="range"]:focus { outline: none; }
        input[type="range"]::-webkit-slider-runnable-track { width: 100%; height: 8px; cursor: pointer; background-image: linear-gradient(to bottom, #666, #4a4a4a); border-radius: 4px; border: 1px solid #2a2a2a; box-shadow: inset 0 1px 1px rgba(0,0,0,0.5), inset 0 1px 0px rgba(255,255,255,0.08); }
        input[type="range"]::-moz-range-track { width: 100%; height: 8px; cursor: pointer; background-image: linear-gradient(to bottom, #666, #4a4a4a); border-radius: 4px; border: 1px solid #2a2a2a; box-shadow: inset 0 1px 1px rgba(0,0,0,0.5), inset 0 1px 0px rgba(255,255,255,0.08); }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; height: 16px; width: 16px; border-radius: 50%; background-image: linear-gradient(to bottom, #ddd, #aaa); border: 1px solid #888; cursor: pointer; margin-top: -4px; box-shadow: 0 1px 2px rgba(0,0,0,0.3), inset 0 0 1px rgba(255,255,255,0.5), inset 0 1px 1px rgba(0,0,0,0.1); transition: background-image 0.1s ease, box-shadow 0.1s ease; }
        input[type="range"]::-webkit-slider-thumb:hover { background-image: linear-gradient(to bottom, #eee, #bbb); box-shadow: 0 1px 3px rgba(0,0,0,0.4), inset 0 0 1px rgba(255,255,255,0.6), inset 0 1px 1px rgba(0,0,0,0.15); }
        input[type="range"]::-webkit-slider-thumb:active { background-image: linear-gradient(to top, #ddd, #aaa); box-shadow: inset 0 1px 3px rgba(0,0,0,0.4); }
        input[type="range"]::-moz-range-thumb { height: 16px; width: 16px; border-radius: 50%; background-image: linear-gradient(to bottom, #ddd, #aaa); border: 1px solid #888; cursor: pointer; box-shadow: 0 1px 2px rgba(0,0,0,0.3), inset 0 0 1px rgba(255,255,255,0.5), inset 0 1px 1px rgba(0,0,0,0.1); transition: background-image 0.1s ease, box-shadow 0.1s ease; }
        input[type="range"]::-moz-range-thumb:hover { background-image: linear-gradient(to bottom, #eee, #bbb); box-shadow: 0 1px 3px rgba(0,0,0,0.4), inset 0 0 1px rgba(255,255,255,0.6), inset 0 1px 1px rgba(0,0,0,0.15); }
        input[type="range"]::-moz-range-thumb:active { background-image: linear-gradient(to top, #ddd, #aaa); box-shadow: inset 0 1px 3px rgba(0,0,0,0.4); }
        .moved-controls-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 6px 8px; align-items: center; justify-content: start; margin-top: 10px; }
        .info-button { display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; font-size: 10px; line-height: 1; border-radius: 50%; border: 1px solid #666; background-color: rgba(80, 80, 80, 0.5); color: #bbb; cursor: pointer; margin-left: 4px; margin-right: auto; padding: 0; vertical-align: middle; transition: background-color 0.2s, border-color 0.2s; flex-shrink: 0; }
        .info-button:hover { background-color: rgba(100, 100, 100, 0.7); border-color: #888; }
        .info-button:active { background-color: rgba(120, 120, 120, 0.8); }
        #paramInfoTooltip { position: absolute; display: none; background-color: rgba(50, 50, 50, 0.95); border: 1px solid #777; border-radius: 6px; padding: 8px 12px; color: #eee; font-size: 0.8rem; line-height: 1.5; max-width: 280px; box-shadow: 0 3px 10px rgba(0,0,0,0.5); z-index: 1010; pointer-events: none; }
        #paramInfoTooltip strong { color: #fff; font-weight: bold; display: block; margin-top: 4px; }
        #paramInfoTooltip strong:first-child { margin-top: 0; }
        #paramInfoTooltip code { background-color: rgba(0,0,0,0.3); padding: 1px 3px; border-radius: 3px; font-family: Consolas, Monaco, monospace; font-size: 0.9em; }
        #deletePresetButton { background-color: #a44; border-color: #c66; } #deletePresetButton:hover { background-color: #c66; border-color: #e88; }
        #regenerateButton { display: none; }
        #modelInfoBody pre { max-height: 60vh; overflow-y: auto; } #modelInfoBody textarea { background-color: #111; color: #ccc; border: 1px solid #444; } #deleteModelButton { margin-left: auto; background-color: #a44; border-color: #c66; } #deleteModelButton:hover { background-color: #c66; border-color: #e88; }
        #systemInfo { position: absolute; bottom: 5px; left: 10px; font-size: 10px; color: #666; transition: opacity 0.8s ease-out; opacity: 1; z-index: 1; }
        #modelInfoButton, #systemPromptButton, #savePresetButton, #deletePresetButton, #importPresetsButton, #exportPresetsButton, #clearChatButton, #clearContextButton, #regenerateButton, #resetParamsButton, #toggleSnippetsButton, #playPauseButton, #refreshModelsButton, #exportChatButton, #importChatsButton, #attachFileButton, #clearAttachmentButton, #micButton { justify-content: center; min-width: 35px; padding: 0 6px; }
        #clearAttachmentButton { min-width: auto; padding: 0 4px; }
        #ttsToggleButton { min-width: 75px; }
        select#modelSelector { min-width: 100px; max-width: 180px; }
        select#modeSelector { min-width: 100px; }
        select#voiceSelector { min-width: 100px; }
        select#presetSelector { min-width: 100px; }
        .search-mode-hidden { display: none !important; }
        .search-mode-disabled { opacity: 0.5; pointer-events: none; cursor: not-allowed; }
        .settings-grid { display: flex; flex-wrap: wrap; gap: 10px 20px; align-items: flex-end; }
        .settings-grid .param-control { flex: 1 1 250px; min-width: 200px; }
        .settings-grid .param-control label { margin-bottom: 2px; }
        .settings-grid .param-control input { height: 28px !important; }
        .movable-panel { display: none; position: absolute; bottom: 85px; left: 15px; width: 280px; max-height: 55vh; background-color: rgba(25, 25, 25, 0.97); border: 1px solid #444; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); z-index: 995; flex-direction: column; overflow: hidden; }
        .movable-panel .panel-header { display: flex; justify-content: space-between; align-items: center; padding: 5px 10px; background-color: #333; border-bottom: 1px solid #444; cursor: move; flex-shrink: 0; }
        .movable-panel .panel-title { font-size: 0.9em; color: #eee; font-weight: bold; }
        .movable-panel .panel-close-button { position: static; background: none; border: none; color: #aaa; font-size: 1.5em; line-height: 1; cursor: pointer; padding: 0 3px; margin-left: auto; }
        .movable-panel .panel-close-button:hover { color: #fff; }
        .movable-panel .panel-content { padding: 10px; flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; scrollbar-width: thin; scrollbar-color: rgba(85, 85, 85, 0.7) rgba(34, 34, 34, 0.5); }
        .movable-panel .panel-content::-webkit-scrollbar { width: 6px; } .movable-panel .panel-content::-webkit-scrollbar-track { background: rgba(34, 34, 34, 0.5); border-radius: 3px; } .movable-panel .panel-content::-webkit-scrollbar-thumb { background-color: rgba(85, 85, 85, 0.7); border-radius: 3px; }
        .playlist-section { border-bottom: 1px solid #333; padding-bottom: 8px; flex-shrink: 0; min-height: 70px; max-height: 40%; display: flex; flex-direction: column; }
        #playlistDisplay { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; font-size: 0.8em; border: 1px solid #333; border-radius: 4px; background-color: rgba(0,0,0,0.3); }
        #playlistDisplay li { padding: 4px 8px; cursor: pointer; border-bottom: 1px solid #282828; color: #bbb; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; justify-content: space-between; align-items: center; }
        #playlistDisplay li:last-child { border-bottom: none; }
        #playlistDisplay li:hover { background-color: rgba(255, 255, 255, 0.08); color: #fff; }
        #playlistDisplay li.playing { font-weight: bold; color: #eeeeee; background-color: rgba(90, 90, 90, 0.25); }
        #playlistDisplay li.playing:hover { background-color: rgba(110, 110, 110, 0.35); }
        #playlistDisplay li .playlist-track-title { flex-grow: 1; overflow: hidden; text-overflow: ellipsis; margin-right: 5px; }
        .remove-track-btn { background: none; border: none; color: #777; cursor: pointer; padding: 0 3px; line-height: 1; font-size: 1.2em; margin-left: 5px; display: none; }
        #playlistDisplay li:hover .remove-track-btn { display: inline; }
        .remove-track-btn:hover { color: #f66; }
        #playlistDisplay li.no-tracks { font-style: italic; color: #666; cursor: default; text-align: center; padding: 10px; display: block; }
        #playlistDisplay li.no-tracks:hover { background-color: transparent; }
        .player-section { flex-grow: 1; display: flex; flex-direction: column; min-height: 110px; overflow: hidden; }
        .track-info { font-size: 0.8em; color: #aaa; margin-bottom: 8px; text-align: center; height: 35px; overflow: hidden; display: flex; flex-direction: column; justify-content: center; border: 1px solid #2a2a2a; background-color: rgba(0,0,0,0.25); border-radius: 4px; padding: 0 5px;}
        #trackName { display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: bold; color: #ddd;}
        #trackTime { display: block; font-size: 0.9em; color: #888; }
        .player-controls { display: flex; justify-content: center; align-items: center; gap: 10px; flex-wrap: wrap; margin-bottom: 8px; }
        .player-button { min-width: 35px; }
        .volume-control { display: flex; align-items: center; gap: 6px; width: 80%; margin: 5px auto 0 auto; justify-content: center; }
        #volumeSlider { flex-grow: 1; height: 10px !important; margin: 0; cursor: pointer; max-width: 180px; }
        #volumeSlider::-webkit-slider-runnable-track { height: 4px; background: #555; border-radius: 2px;}
        #volumeSlider::-moz-range-track { height: 4px; background: #555; border-radius: 2px;}
        #volumeSlider::-webkit-slider-thumb { height: 12px; width: 12px; margin-top: -4px;}
        #volumeSlider::-moz-range-thumb { height: 12px; width: 12px; }
        .player-section .file-input-area { margin-top: 12px; }
        .file-input-label { width: 100%; justify-content: center; }

    </style>
</head>
<body>
     <canvas id="particleCanvas"></canvas>
    <div class="container">
         <div class="orb-shape-container"><div class="orb-shape" id="orbShapeDiv"><canvas id="orbParticleCanvas"></canvas></div></div>
         <div id="chatDisplayArea"></div>
         <div class="input-area" id="inputArea">
             <div id="advancedControls">
                 <details>
                     <summary>+</summary>
                     <div class="details-content-wrapper">
                         <div class="param-grid" id="paramGrid">
                             <div class="param-control"><label for="temperatureControl">Temperature: <button class="info-button" data-param-info="temperature" title="Parameter Info">ℹ️</button> <span id="temperatureValue" class="param-value">1.0</span></label><input type="range" id="temperatureControl" data-param="temperature" min="0" max="2" step="0.05" value="1.0"></div>
                             <div class="param-control"><label for="topPControl">Top P: <button class="info-button" data-param-info="top_p" title="Parameter Info">ℹ️</button> <span id="topPValue" class="param-value">0.9</span></label><input type="range" id="topPControl" data-param="top_p" min="0" max="1" step="0.05" value="0.9"></div>
                             <div class="param-control"><label for="topKControl">Top K: <button class="info-button" data-param-info="top_k" title="Parameter Info">ℹ️</button> <span id="topKValue" class="param-value">40</span></label><input type="number" id="topKControl" data-param="top_k" min="0" step="1" value="40"></div>
                             <div class="param-control"><label for="repeatPenaltyControl">Repeat Penalty: <button class="info-button" data-param-info="repeat_penalty" title="Parameter Info">ℹ️</button> <span id="repeatPenaltyValue" class="param-value">1.1</span></label><input type="range" id="repeatPenaltyControl" data-param="repeat_penalty" min="1.0" max="2.0" step="0.05" value="1.1"></div>
                             <div class="param-control"><label for="seedControl">Seed (0=random): <button class="info-button" data-param-info="seed" title="Parameter Info">ℹ️</button> <span id="seedValue" class="param-value">0</span></label><input type="number" id="seedControl" data-param="seed" min="0" step="1" value="0"></div>
                             <div class="param-control"><label for="numCtxControl">Context Window (0=auto): <button class="info-button" data-param-info="num_ctx" title="Parameter Info">ℹ️</button> <span id="numCtxValue" class="param-value">0</span></label><input type="number" id="numCtxControl" data-param="num_ctx" min="0" step="64" value="0"></div>
                             <div class="param-control"><label for="stopControl">Stop Sequence(s): <button class="info-button" data-param-info="stop" title="Parameter Info">ℹ️</button></label><input type="text" id="stopControl" data-param="stop" placeholder="e.g. User:,Human:"></div>
                         </div>
                         <div class="settings-grid" style="border-top: 1px solid #333; padding-top: 15px;">
                               <div class="param-control"><label for="ollamaUrlInput">Ollama API URL (Backend Use):</label><input type="text" id="ollamaUrlInput" class="control-item" placeholder="e.g., http://localhost:11434" style="height: 28px;"></div>
                              <div class="param-control"><label for="ollamaModelInput">Ollama Model (for Web Search):</label><input type="text" id="ollamaModelInput" class="control-item" placeholder="e.g., llama3:latest" style="height: 28px;"></div>
                         </div>
                         <button id="saveSettingsButton" class="control-item" style="margin-top: 10px; width: auto;">Save Ollama Settings</button>
                         <span id="settingsSaveStatus" style="font-size: 0.8em; margin-left: 10px; color: #3a7; display: none;">Saved!</span>
                         <hr style="border: none; border-top: 1px solid #333; margin: 15px 0;">
                         <div class="moved-controls-grid" id="mainControlsGrid">
                             <select id="modelSelector" class="control-item" title="Select Source"></select>
                             <button id="modelInfoButton" class="control-item ollama-only" title="Show Model Info"><i data-feather="info"></i></button>
                             <button id="refreshModelsButton" class="control-item ollama-only" title="Refresh Model List"><i data-feather="refresh-ccw"></i></button>
                             <select id="modeSelector" class="control-item ollama-only" title="Select Personality Mode"><option value="chat">Chat</option><option value="coder">Coder</option><option value="business">Business</option><option value="creative">Creative</option><option value="wizard">Wizard</option><option value="custom" disabled hidden>Custom</option></select>
                             <button id="systemPromptButton" class="control-item ollama-only" title="Edit System Prompt"><i data-feather="cpu"></i></button>
                             <select id="voiceSelector" class="control-item" title="Select Voice"></select>
                             <button id="ttsToggleButton" class="control-item" title="Enable/Disable Speech Output"><i data-feather="volume-x" id="ttsIcon"></i><span id="ttsLabel">TTS Off</span></button>
                             <button id="playPauseButton" class="control-item paused" title="Play Speech"><i data-feather="play" id="playPauseIcon"></i></button>
                             <button id="fastForwardButton" class="control-item" title="Cycle Speech Rate">⏩︎<span class="rate-display">1.0x</span></button>
                             <select id="presetSelector" class="control-item" title="Load Preset"><option value="">Load Preset...</option></select>
                             <button id="savePresetButton" class="control-item" title="Save Current Settings as Preset"><i data-feather="save"></i></button>
                             <button id="deletePresetButton" class="control-item" title="Delete Selected Preset" disabled><i data-feather="trash-2"></i></button>
                             <button id="importPresetsButton" class="control-item" title="Import Presets"><i data-feather="download"></i></button>
                             <input type="file" id="importPresetsInput" accept=".json" style="display: none;">
                             <button id="exportPresetsButton" class="control-item" title="Export All Presets"><i data-feather="upload"></i></button>
                             <button id="importChatsButton" class="control-item" title="Import Chat History"><i data-feather="download"></i></button>
                             <input type="file" id="importChatsInput" accept=".json" style="display: none;">
                             <button id="exportChatButton" class="control-item" title="Export Chat History"><i data-feather="share-2"></i></button>
                             <button id="clearChatButton" class="control-item" title="Clear Chat History"><i data-feather="file-minus"></i></button>
                             <button id="clearContextButton" class="control-item ollama-only" title="Clear Context (Keep History)"><i data-feather="zap-off"></i></button>
                             <button id="regenerateButton" class="control-item" title="Regenerate Last Response"><i data-feather="refresh-cw"></i></button>
                             <button id="toggleSnippetsButton" class="control-item" title="Show/Hide Saved Snippets"><i data-feather="clipboard"></i></button>
                             <button id="toggleMusicPanelButton" class="control-item" title="Toggle Music Player"><i data-feather="music"></i></button>
                             <button id="resetParamsButton" class="control-item" title="Reset Parameters to Default"><i data-feather="settings"></i></button>
                         </div>
                     </div>
                 </details>
             </div>
             <div class="input-row">
                  <button id="attachFileButton" class="control-item" title="Attach Text File"><i data-feather="paperclip"></i></button>
                  <input type="file" id="attachFileInput" accept=".txt,.md,.js,.py,.html,.css,.json,text/plain" style="display: none;">
                  <div id="attachmentDisplay" style="display: none;"><span id="attachedFileName"></span><button id="clearAttachmentButton" class="control-item" title="Clear Attachment"><i data-feather="x"></i></button></div>
                  <textarea id="questionInput" placeholder="Select a source" rows="1"></textarea>
                  <button id="micButton" class="control-item" title="Start Voice Input"><i data-feather="mic"></i></button>
                  <button id="stopGeneratingButton" class="control-item" title="Stop Current Response" style="display: none;">Stop</button>
             </div>
         </div>
         <div id="systemInfo">Status: Ready</div>
    </div>

     <div id="musicPlayerPanel" class="movable-panel" style="display: none;">
         <div class="panel-header" id="musicPlayerHeader"><span class="panel-title">Music Player</span><button id="closeMusicPanelButton" class="panel-close-button" title="Close Player">&times;</button></div>
         <div class="panel-content">
             <div class="playlist-section"><ul id="playlistDisplay"><li class="no-tracks">No tracks loaded.</li></ul></div>
             <div class="player-section">
                 <div id="trackInfo" class="track-info"><span id="trackName">No Track Loaded</span><span id="trackTime">0:00 / 0:00</span></div>
                 <div class="player-controls"><button id="prevTrackButton" class="control-item player-button" title="Previous Track"><i data-feather="skip-back"></i></button><button id="playPausePlayerButton" class="control-item player-button" title="Play/Pause"><i data-feather="play"></i></button><button id="nextTrackButton" class="control-item player-button" title="Next Track"><i data-feather="skip-forward"></i></button></div>
                 <div class="volume-control"><i data-feather="volume-2"></i><input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.8" title="Volume"></div>
                 <div class="file-input-area" style="margin-top: 15px;"><label for="audioFileInput" class="control-item file-input-label"><i data-feather="plus-circle"></i></label><input type="file" id="audioFileInput" accept="audio/*" multiple style="display: none;"></div>
             </div>
         </div>
     </div>

    <div id="snippetsPanel" style="display: none;"><h4>Saved Snippets</h4><ul id="snippetsList"></ul></div>

    <div id="systemPromptModal" class="modal-overlay"> <div class="modal-content"><div class="modal-header"><span class="modal-title">System Prompt</span><button id="systemPromptCloseButton" class="modal-close" title="Close">&times;</button></div><div class="modal-body"><textarea id="systemPromptTextarea" placeholder="Enter system prompt here..."></textarea></div><div class="modal-footer"><button id="systemPromptCancelButton" class="modal-button cancel">Cancel</button><button id="systemPromptSaveButton" class="modal-button save">Save</button></div></div> </div>
    <div id="modelInfoModal" class="modal-overlay"> <div class="modal-content"><div class="modal-header"><span id="modelInfoTitle" class="modal-title">Model Information</span><button id="modelInfoCloseButton" class="modal-close" title="Close">&times;</button></div><div id="modelInfoBody" class="modal-body"><pre>Loading...</pre></div><div class="modal-footer"><button id="deleteModelButton" class="modal-button cancel" title="Delete this model permanently">Delete Model</button><button id="modelInfoOkButton" class="modal-button">OK</button></div></div> </div>

    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <script>
        try {
            'use strict';
            const OLLAMA_API_BASE = 'http://localhost:11434';
            const BACKEND_SOURCE_VALUE = 'orbe_backend_search';
            const CHAT_HISTORY_STORAGE_KEY = 'orbeChatHistory_v1';

            const getElem = (id, required = true) => { const elem = document.getElementById(id); if (required && !elem && id) { console.error(`Essential element missing: #${id}`); } return elem; };
            // Define all DOM element constants first
            const chatDisplayArea = getElem('chatDisplayArea'), questionInput = getElem('questionInput'), inputArea = getElem('inputArea'), stopGeneratingButton = getElem('stopGeneratingButton'), modelSelector = getElem('modelSelector'), systemInfo = getElem('systemInfo'), voiceSelector = getElem('voiceSelector'), ttsToggleButton = getElem('ttsToggleButton'), ttsIcon = getElem('ttsIcon'), ttsLabel = getElem('ttsLabel'), clearChatButton = getElem('clearChatButton'), playPauseButton = getElem('playPauseButton'), playPauseIcon = getElem('playPauseIcon'), fastForwardButton = getElem('fastForwardButton'), ffRateDisplay = fastForwardButton?.querySelector('.rate-display'), toggleSnippetsButton = getElem('toggleSnippetsButton'), snippetsPanel = getElem('snippetsPanel'), snippetsList = getElem('snippetsList'), systemPromptButton = getElem('systemPromptButton'), systemPromptModal = getElem('systemPromptModal'), systemPromptTextarea = getElem('systemPromptTextarea'), systemPromptSaveButton = getElem('systemPromptSaveButton'), systemPromptCancelButton = getElem('systemPromptCancelButton'), systemPromptCloseButton = getElem('systemPromptCloseButton'), advancedControlsDiv = getElem('advancedControls'), paramGrid = getElem('paramGrid'), temperatureControl = getElem('temperatureControl', false), temperatureValue = getElem('temperatureValue', false), topPControl = getElem('topPControl', false), topPValue = getElem('topPValue', false), topKControl = getElem('topKControl', false), topKValue = getElem('topKValue', false), repeatPenaltyControl = getElem('repeatPenaltyControl', false), repeatPenaltyValue = getElem('repeatPenaltyValue', false), seedControl = getElem('seedControl', false), seedValue = getElem('seedValue', false), numCtxControl = getElem('numCtxControl', false), numCtxValue = getElem('numCtxValue', false), stopControl = getElem('stopControl', false), resetParamsButton = getElem('resetParamsButton', false), regenerateButton = getElem('regenerateButton'), modelInfoButton = getElem('modelInfoButton'), modelInfoModal = getElem('modelInfoModal'), modelInfoTitle = getElem('modelInfoTitle'), modelInfoBody = getElem('modelInfoBody'), modelInfoOkButton = getElem('modelInfoOkButton'), modelInfoCloseButton = getElem('modelInfoCloseButton'), deleteModelButton = getElem('deleteModelButton'), presetSelector = getElem('presetSelector'), savePresetButton = getElem('savePresetButton'), deletePresetButton = getElem('deletePresetButton'), exportPresetsButton = getElem('exportPresetsButton'), importPresetsButton = getElem('importPresetsButton'), importPresetsInput = getElem('importPresetsInput'), clearContextButton = getElem('clearContextButton'), modeSelector = getElem('modeSelector'), refreshModelsButton = getElem('refreshModelsButton'), exportChatButton = getElem('exportChatButton'), importChatsButton = getElem('importChatsButton'), importChatsInput = getElem('importChatsInput'), attachFileButton = getElem('attachFileButton'), attachFileInput = getElem('attachFileInput'), attachmentDisplay = getElem('attachmentDisplay'), attachedFileName = getElem('attachedFileName'), clearAttachmentButton = getElem('clearAttachmentButton');
            const ollamaModelInput = getElem('ollamaModelInput', false), ollamaUrlInput = getElem('ollamaUrlInput', false), saveSettingsButton = getElem('saveSettingsButton', false), settingsSaveStatus = getElem('settingsSaveStatus', false);
            const musicPlayerPanel = getElem('musicPlayerPanel', false), musicPlayerHeader = getElem('musicPlayerHeader', false), toggleMusicPanelButton = getElem('toggleMusicPanelButton', false), closeMusicPanelButton = getElem('closeMusicPanelButton', false), audioFileInput = getElem('audioFileInput', false), playlistDisplay = getElem('playlistDisplay', false), trackNameEl = getElem('trackName', false), trackTimeEl = getElem('trackTime', false), playPausePlayerButton = getElem('playPausePlayerButton', false), prevTrackButton = getElem('prevTrackButton', false), nextTrackButton = getElem('nextTrackButton', false), volumeSlider = getElem('volumeSlider', false);
            const bgCanvas = getElem('particleCanvas', false), orbCanvas = getElem('orbParticleCanvas'), orbShapeDiv = getElem('orbShapeDiv');
            const bgCtx = bgCanvas ? bgCanvas.getContext('2d') : null, orbCtx = orbCanvas ? orbCanvas.getContext('2d') : null;
            const MicButton = getElem('micButton');

            // State Variables
            let bgAnimationFrameId = null, orbAnimationFrameId = null, isSpeaking = false, orbAnimationMode = 'relaxed', targetOrbHue = Math.random() * 360, thinkingFlag = false, isGeneratingStream = false, globalBgHue = Math.random() * 360, chatHistory = [], thinkingMessageElement = null, currentAbortController = null, isTtsEnabled = false, currentSource = '', selectedMode = 'chat', availableVoices = [], selectedVoice = null, MAX_CONTEXT_TURNS = 3, currentUtterance = null, currentRateIndex = 0, resizeTimeout = null, bgParticlesArray = [], orbParticlesArray = [], currentEditingBlockWrapper = null, currentSystemPrompt = "", generationParams = {}, lastSubmission = { prompt: null, context: null, source: null, options: null }, presets = [], paramInfoTooltip = null, currentInfoButton = null, attachedFileContent = null, attachedFileDetails = null;
            const MAX_ATTACHMENT_SIZE_MB = 5, bgNumberOfParticles = 50, SNIPPETS_STORAGE_KEY = 'orbeSavedSnippets_v1', SETTINGS_STORAGE_KEY = 'orbeSettings_v1', PRESET_STORAGE_KEY = 'orbePresets_v1', ttsRates = [1.0, 1.5, 2.0];
            const ORB_PARTICLE_COUNT = 400, ORB_SPEED_BASE = 0.0006, ORB_SPEED_VAR = 0.0012, ORB_SIZE_BASE = 0.8, ORB_SIZE_VAR = 2.5, ORB_ALPHA_BASE = 0.2, ORB_ALPHA_VAR = 0.5, ORB_HUE_VAR = 60, ORB_DAMPING = 0.99, ORB_CENTER_PULL_RELAXED = 0.00003, ORB_CENTER_PULL_THINKING = -0.0010, ORB_EXPANSION_FORCE = 0.00010, ORB_SWIRL_RELAXED = 0.005, ORB_SWIRL_THINKING = 0.025, ORB_WAVE_AMP_SPEAKING = 0.3, ORB_WAVE_FREQ_SPEAKING = 0.07, ORB_WAVE_SPEED_SPEAKING = 0.0004, ORB_BOUNCE_THRESHOLD = 10, ORB_BOUNCE_FORCE = 0.04, SHAKE_INTENSITY_THINKING = 0.15;
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            let recognition = null, isListening = false;

            // Constants (Condensed)
            const ICONS = { play: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>`, pause: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`, saveSnippet: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>`, edit: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>`, explain: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`, refactor: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>`, use: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg>`, copy: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`, copied: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`, saved: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>`, bug: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 9V6a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v3"></path><path d="M1 11h22"></path><path d="m13 22 8-9"></path><path d="M18 13v5a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2v-5"></path><path d="m4 13-3 9"></path></svg>`, optimize: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline></svg>`, document: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>` };
            const MODE_PROMPTS = { default: `You are orbe, a friendly, helpful, conversational AI assistant. Engage naturally, making the interaction a pleasant chat, not robotic. Ask clarifying questions. Synthesize provided context (search results, articles, etc.) with the user's query. If context is irrelevant/missing, use general knowledge.\n**Respond ONLY in English.**`, chat: `You are orbe, a friendly, helpful, conversational AI assistant. Engage naturally, making the interaction a pleasant chat, not robotic. Ask clarifying questions. Synthesize provided context (search results, articles, etc.) with the user's query. If context is irrelevant/missing, use general knowledge.\n**Respond ONLY in English.**`, coder: `You are orbe, acting as an "AI coding expert". Use context (search results, docs) & query for accurate, efficient code/explanations (clear, correct, secure). Use markdown for code. If context irrelevant, use coding knowledge.\n**Respond ONLY in English.**`, business: `You are orbe, acting as an "AI business consultant". Analyze context (search results, market data) & query for actionable insights/strategy (clear, cost-effective, market-focused). If context irrelevant, use business principles.\n**Respond ONLY in English.**`, creative: `You are orbe, acting as an "AI creative partner". Use context (search results, creative works) & query to brainstorm innovative ideas/solutions (original, imaginative, feasible). If context irrelevant, use general knowledge creatively.\n**Respond ONLY in English.**`, wizard: `WIZARD MODE: You are orbe, high-efficiency mode. Use context if relevant. BE EXTREMELY CONCISE (points/minimal words). OMIT conversational filler/introductions/summaries/apologies/self-references. Provide ONLY core output (code, list, answer). Ask questions ONLY if critically needed.\n**Respond ONLY in English.**`, custom: "" };
            const PARAM_INFO_TEXT = { temperature: `<strong>What:</strong> Controls randomness. Higher values increase diversity/creativity.<br><strong>Range:</strong> 0.0-2.0. Default: 1.0.`, top_p: `<strong>What:</strong> Nucleus Sampling. Considers words whose probability > P.<br><strong>Range:</strong> 0.0-1.0. Default: 0.9.`, top_k: `<strong>What:</strong> Limits selection to K most likely words.<br><strong>Range:</strong> 0+ (0=disabled). Default: 40.`, repeat_penalty: `<strong>What:</strong> Penalizes recently used words.<br><strong>Range:</strong> 1.0+ (1=none). Default: 1.1.`, seed: `<strong>What:</strong> Random seed.<br><strong>Example:</strong> 0=Random, 123=Reproducible.`, num_ctx: `<strong>What:</strong> Context Window Size.<br><strong>Example:</strong> 0=Default, 2048, 4096.`, stop: `<strong>What:</strong> Stop Sequences.<br><strong>Example:</strong> User:,###` };

            // --- Helper Functions ---

            function resetTtsControls() {
                currentUtterance = null;
                orbAnimationMode = 'relaxed';
                if (playPauseButton) {
                    playPauseButton.classList.remove('playing', 'tts-playing');
                    playPauseButton.classList.add('paused');
                    playPauseButton.title = 'Play Speech';
                    if (playPauseIcon) playPauseIcon.setAttribute('data-feather', 'play');
                }
                hideTtsControls();
                if (playPauseIcon && typeof feather !== 'undefined') {
                    try { feather.replace({ 'stroke-width': 1.8, width: 14, height: 14 }); } catch (e) { console.warn("Feather error in resetTtsControls", e); }
                }
            }

            function speakText(text, forceSpeak = false, isCodeBlock = false, callingButton = null) {
                if (!('speechSynthesis' in window)) { console.warn("Speech Synthesis not supported."); if (callingButton) flashButtonState(callingButton, 'error', 'play'); return; }
                if (!isTtsEnabled && !forceSpeak && !isCodeBlock) return;
                if (!selectedVoice && voiceSelector?.value !== 'default') console.warn("TTS voice not selected or available, using default.");
                try {
                    let speakableText = text;
                    if (!isCodeBlock) { const codeBlockRegex = /^```(\w*)\n([\s\S]*?)\n```$/gm; speakableText = speakableText.replace(codeBlockRegex, '\n(Code block omitted)\n').replace(/\[([^\]]+)\]\([^)]+\)/g, '$1').replace(/[*#`_~]/g, ' ').replace(/\s+/g, ' ').trim(); }
                    else { speakableText = speakableText.trim(); }
                    if (speakableText.length === 0) { console.log("No speakable text found."); if (callingButton) flashButtonState(callingButton, 'error', 'play'); return; }
                    window.speechSynthesis.cancel(); isSpeaking = false; orbAnimationMode = 'relaxed';
                    document.querySelectorAll('.code-block-button.playing-tts').forEach(btn => btn.classList.remove('playing-tts'));
                    if (callingButton) callingButton.classList.add('playing-tts');
                    currentUtterance = new SpeechSynthesisUtterance(speakableText); let utterance = currentUtterance;
                    utterance.lang = selectedVoice?.lang || 'en-US'; utterance.rate = ttsRates[currentRateIndex]; utterance.pitch = 1.0;
                    if (selectedVoice) { utterance.voice = selectedVoice; }
                    else { const defaultVoice = availableVoices.find(v => v.default && v.lang.startsWith('en-')) || availableVoices.find(v => v.lang.startsWith('en-')); if (defaultVoice) utterance.voice = defaultVoice; }
                    utterance.onstart = () => { console.log("TTS started."); isSpeaking = true; orbAnimationMode = 'speaking'; if (!isCodeBlock && !forceSpeak) showTtsControls(); };
                    utterance.onend = () => { console.log("TTS ended."); isSpeaking = false; orbAnimationMode = 'relaxed'; if (currentUtterance === utterance) { currentUtterance = null; if (!isCodeBlock) resetTtsControls(); } if (callingButton) callingButton.classList.remove('playing-tts'); if (!thinkingFlag && !isListening) showInputControls(true); };
                    utterance.onerror = (event) => { isSpeaking = false; orbAnimationMode = 'relaxed'; if (event.error === 'interrupted') { console.log("TTS interrupted."); } else { console.error("TTS error:", event.error); if (systemInfo) { systemInfo.textContent = `TTS Error: ${event.error}`; systemInfo.style.opacity = '1'; systemInfo.style.color = 'orange'; setTimeout(() => { if (systemInfo?.textContent.startsWith('TTS Error')) systemInfo.style.opacity = '0'; }, 5000); } } if (currentUtterance === utterance) { currentUtterance = null; if (!isCodeBlock) resetTtsControls(); } if (callingButton) { callingButton.classList.remove('playing-tts'); if(event.error !== 'interrupted') flashButtonState(callingButton, 'error', 'play'); } if (!thinkingFlag && !isListening) showInputControls(true); };
                    setTimeout(() => { window.speechSynthesis.speak(utterance); }, 50);
                } catch (e) { console.error("Error in speakText function:", e); isSpeaking = false; orbAnimationMode = 'relaxed'; resetTtsControls(); if (!thinkingFlag && !isListening) showInputControls(true); if (callingButton) { callingButton.classList.remove('playing-tts'); flashButtonState(callingButton, 'error', 'play'); } }
            }

            function populateVoiceList() { if (!('speechSynthesis' in window)) { console.warn("Speech Synthesis not supported."); if (voiceSelector) voiceSelector.disabled = true; if (ttsToggleButton) ttsToggleButton.disabled = true; return; } try { availableVoices = window.speechSynthesis.getVoices(); if (availableVoices.length === 0) { console.warn("Voice list empty. Retrying soon or waiting for onvoiceschanged."); return; } console.log(`Found ${availableVoices.length} voices.`); const currentVal = voiceSelector.value; voiceSelector.innerHTML = '<option value="default" selected>Default</option>'; const m=/male|david|mark|guy|man|tom|microsoft david/i; const f=/female|zira|susan|hazel|woman|linda|kim|microsoft zira/i; const i=/irvin|microsoft mark/i; let foundSelection = false; availableVoices.forEach((v, x) => { if (v.lang.startsWith('en-') && !i.test(v.name)) { const o=document.createElement('option'); o.value=x; let d=v.name.replace(/\(.*\)/,'').replace('Microsoft ','').replace('Google ','').trim(); if(m.test(v.name))d+=" (M)"; else if(f.test(v.name))d+=" (F)"; o.textContent=d; if (v.name === selectedVoice?.name) { o.selected = true; foundSelection = true; } else if (!selectedVoice && currentVal === x.toString()){ o.selected = true; foundSelection = true; } voiceSelector.appendChild(o); } }); if (!foundSelection && currentVal !== 'default') { const parsedIndex = parseInt(currentVal); if (!isNaN(parsedIndex) && voiceSelector.options[parsedIndex+1]) { voiceSelector.value = currentVal; selectedVoice = availableVoices[parsedIndex]; foundSelection = true; } } if (!foundSelection) { voiceSelector.value = "default"; selectedVoice = null; } else { selectedVoice = (voiceSelector.value !== 'default') ? availableVoices[parseInt(voiceSelector.value)] : null; } console.log("Voice list populated. Selected:", selectedVoice?.name || "Default"); } catch(e){ console.error("Error populating voice list:", e); } }
            function setupBgCanvas() { if (!bgCanvas) return false; bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight; return true; }
            class BgParticle { constructor(){this.x=Math.random()*(bgCanvas?.width||innerWidth);this.y=Math.random()*(bgCanvas?.height||innerHeight);this.size=Math.random()*2+0.5;this.sx=Math.random()*1-0.5;this.sy=Math.random()*1-0.5;this.sat=50+Math.random()*30;this.light=70+Math.random()*20;this.alpha=Math.random()*0.4+0.1;} draw(){if(!bgCtx)return;const hue=globalBgHue;bgCtx.fillStyle=`hsla(${hue}, ${this.sat}%, ${this.light}%, ${this.alpha})`;bgCtx.shadowBlur=4;bgCtx.shadowColor=`hsla(${hue}, ${this.sat}%, ${this.light}%, 0.4)`;bgCtx.beginPath();bgCtx.arc(this.x,this.y,this.size,0,Math.PI*2);bgCtx.fill();bgCtx.shadowBlur=0;} update(){if(!bgCanvas?.width||!bgCanvas?.height)return;this.x+=this.sx;this.y+=this.sy;if(this.x<this.size||this.x>bgCanvas.width-this.size){this.sx*=-1;this.x=Math.max(this.size,Math.min(this.x,bgCanvas.width-this.size));}if(this.y<this.size||this.y>bgCanvas.height-this.size){this.sy*=-1;this.y=Math.max(this.size,Math.min(this.y,bgCanvas.height-this.size));}this.alpha+=(Math.random()-0.5)*0.04;this.alpha=Math.max(0.1,Math.min(this.alpha,0.5));}} function initBgParticles() { if(!bgCanvas || !bgCtx) return; bgParticlesArray=[]; try { for(let i=0; i<bgNumberOfParticles; i++) bgParticlesArray.push(new BgParticle()); } catch(e){ console.error("Error creating BG particles", e); bgParticlesArray = []; } } function animateBgParticles() { if (!bgCtx || bgParticlesArray.length === 0) { bgAnimationFrameId = requestAnimationFrame(animateBgParticles); return; } try { bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height); globalBgHue=(globalBgHue+0.5)%360; bgParticlesArray.forEach(p=>{p.update();p.draw();}); } catch(e){ console.error("Error in BG animation loop", e); bgAnimationFrameId = null; return; } bgAnimationFrameId = requestAnimationFrame(animateBgParticles); }
            function showInputControls(show) { try { const enable = show && !thinkingFlag && !isListening; if (stopGeneratingButton) stopGeneratingButton.style.display = thinkingFlag ? 'inline-flex' : 'none'; if (questionInput) questionInput.disabled = !enable || !currentSource; if (attachFileButton) attachFileButton.disabled = !enable; const micButtonRef = getElem('micButton', false); if (micButtonRef) micButtonRef.disabled = !recognition || isListening || thinkingFlag; } catch (e) { console.error("Error in showInputControls:", e); } }
            function showTtsControls() { if (isTtsEnabled && playPauseButton && fastForwardButton && playPauseIcon) { playPauseButton.style.display = 'inline-flex'; fastForwardButton.style.display = 'inline-flex'; const isCurrentlyPaused = speechSynthesis.paused && isSpeaking; playPauseButton.classList.toggle('paused', isCurrentlyPaused || !isSpeaking); playPauseButton.classList.toggle('playing', !isCurrentlyPaused && isSpeaking); playPauseButton.classList.toggle('tts-playing', !isCurrentlyPaused && isSpeaking); playPauseButton.title = isCurrentlyPaused ? 'Resume Speech' : (isSpeaking ? 'Pause Speech' : 'Play Speech'); playPauseIcon.setAttribute('data-feather', isCurrentlyPaused ? 'play' : (isSpeaking ? 'pause' : 'play')); if (typeof feather !== 'undefined') { try { feather.replace({ 'stroke-width': 1.8, width: 14, height: 14 }); } catch (e) { console.warn("Feather error in showTtsControls", e); }} } }
            function hideTtsControls() { if (playPauseButton) playPauseButton.style.display = 'none'; if (fastForwardButton) fastForwardButton.style.display = 'none'; }
            function escapeHtml(unsafe) { return typeof unsafe !== 'string' ? unsafe : unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
            function scrollToBottom() { try { chatDisplayArea.scrollTop = chatDisplayArea.scrollHeight; } catch(e){} }
            function adjustTextareaHeight() { try { if(!questionInput) return; questionInput.style.height = 'auto'; const scrollHeight = questionInput.scrollHeight; const maxHeight = 100; questionInput.style.height = `${Math.min(scrollHeight, maxHeight)}px`; } catch(e) { console.error("Error adjusting textarea height:", e); } }
            function adjustInlineTextareaHeight(textarea) { try { textarea.style.height = 'auto'; const scrollHeight = textarea.scrollHeight; const minHeight = 80; const maxHeight = 400; textarea.style.height = `${Math.max(minHeight, Math.min(scrollHeight, maxHeight))}px`; } catch(e) { console.error("Error adjusting inline textarea height:", e); } }
            function flashButtonState(button, className, revertIconKey) { if (!button) return; const originalContent = button.innerHTML; const revertContent = (revertIconKey && ICONS[revertIconKey]) ? ICONS[revertIconKey] : originalContent; let feedbackContent = ''; if (className === 'copied' && ICONS.copied) { feedbackContent = ICONS.copied; } else if (className === 'saved' && ICONS.saved) { feedbackContent = ICONS.saved; } else if (className === 'playing-tts' && ICONS.play) { feedbackContent = ICONS.play; } else if (className === 'error') { feedbackContent = '❌'; } else { feedbackContent = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`; } button.classList.add(className); button.innerHTML = feedbackContent; setTimeout(() => { button.classList.remove(className); if(button.innerHTML === feedbackContent || className === 'playing-tts' || className === 'error'){ button.innerHTML = revertContent; } }, className === 'playing-tts' ? 500 : 1200); }
            function createCopyButton(textToCopy){ const btn=document.createElement('button'); btn.className='copy-button'; btn.innerHTML=ICONS.copy || '📋'; btn.title='Copy Message'; btn.onclick=(e)=>{e.stopPropagation(); navigator.clipboard.writeText(textToCopy).then(()=>{ flashButtonState(btn, 'copied', 'copy'); }).catch(err=>{ console.error('Copy failed:', err); btn.innerHTML='❌'; setTimeout(()=>{btn.innerHTML=ICONS.copy || '📋';},1200); }); }; return btn; }
            function loadSnippets() { try { const s = localStorage.getItem(SNIPPETS_STORAGE_KEY); return s ? JSON.parse(s) : []; } catch (e) { console.error("Failed to load snippets:", e); return []; } } function saveSnippets(snippets) { try { localStorage.setItem(SNIPPETS_STORAGE_KEY, JSON.stringify(snippets)); } catch (e) { console.error("Could not save snippet:", e); alert("Could not save snippet."); } } function renderSnippetsPanel() { try { const snippets = loadSnippets(); snippetsList.innerHTML = ''; if (snippets.length === 0) { snippetsList.innerHTML = '<li class="no-snippets">No snippets saved yet.</li>'; return; } snippets.forEach((snippet, index) => { const li = document.createElement('li'); const firstLine = snippet.code.split('\n')[0].trim(); const preview = firstLine.length > 50 ? firstLine.substring(0, 47) + '...' : firstLine; li.innerHTML = `<div class="snippet-info"><span class="snippet-lang">${escapeHtml(snippet.lang||'text')}</span> <span class="snippet-preview">${escapeHtml(preview)}</span></div><div class="snippet-actions"><button class="use-snippet-button" data-index="${index}" title="Use Snippet">Use</button><button class="delete-snippet-button delete" data-index="${index}" title="Delete Snippet">Del</button></div>`; snippetsList.appendChild(li); }); } catch (e) { console.error("Error rendering snippets panel:", e); } } function addSnippet(lang, code, buttonElement) { if (!code || !code.trim()) return; try { const snippets = loadSnippets(); const isDuplicate = snippets.some(s => s.code === code); if (isDuplicate) { flashButtonState(buttonElement, 'saved', 'saveSnippet'); return; } snippets.unshift({ lang: lang || 'plaintext', code: code }); saveSnippets(snippets); renderSnippetsPanel(); flashButtonState(buttonElement, 'saved', 'saveSnippet'); } catch(e){ console.error("Error adding snippet:", e); } } function deleteSnippet(index) { try { let snippets = loadSnippets(); if (index >= 0 && index < snippets.length) { snippets.splice(index, 1); saveSnippets(snippets); renderSnippetsPanel(); } } catch(e){ console.error("Error deleting snippet:", e); } } function useSnippet(index) { try { const snippets = loadSnippets(); if (index >= 0 && index < snippets.length) { questionInput.value = snippets[index].code; adjustTextareaHeight(); questionInput.focus(); snippetsPanel.style.display = 'none'; } } catch (e) { console.error("Error using snippet:", e); } }
            function triggerTextFileDownload(content, filename) { try { const blob = new Blob([content], { type: 'text/plain;charset=utf-8' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(link.href); } catch (error) { console.error("Error downloading file:", error); } } function saveSessionLogOnUnload(event) { if (chatHistory.length === 0) return; let log = `--- orbe Log ---\nSource Used: ${currentSource}\n`; if (currentSource !== BACKEND_SOURCE_VALUE) { log += `Mode: ${selectedMode}${selectedMode === 'custom' ? ' (Custom)' : ''}\n`; } log += `Session End: ${new Date().toLocaleString()}\n--------------------\n\n`; chatHistory.forEach((entry, index) => { log += `--- Turn ${index + 1} (${entry.timestamp.toLocaleTimeString()}) ---\n[User]:\n${entry.question}\n\n[orbe]:\n${entry.isError ? '[ERROR] ' : ''}${entry.answer}\n\n`; }); log += "--- End of Log ---"; const ts = new Date(); const filename = `orbe_Log_${ts.getFullYear()}${String(ts.getMonth()+1).padStart(2,'0')}${String(ts.getDate()).padStart(2,'0')}_${String(ts.getHours()).padStart(2,'0')}${String(ts.getMinutes()).padStart(2,'0')}${String(ts.getSeconds()).padStart(2,'0')}.txt`; try { triggerTextFileDownload(log, filename); } catch(e) { console.error("Error saving session log:", e); } }
            function processMessageContent(rawText, isError = false) { if (isError || !rawText) { return escapeHtml(rawText || '').replace(/\n/g, '<br>'); } const cleanedText = rawText.replace(/<think>[\s\S]*?<\/think>\n*/g, '').trim(); if (!cleanedText) return ''; const codeBlockRegex = /^```(\w*)\n([\s\S]*?)\n```$/gm; let lastIndex = 0; let resultHtml = ""; try { cleanedText.replace(codeBlockRegex, (match, lang, code, offset) => { resultHtml += escapeHtml(cleanedText.substring(lastIndex, offset)).replace(/\n/g, '<br>'); const language = (lang || 'plaintext').toLowerCase(); const languageClass = `language-${language}`; const escapedCode = escapeHtml(code); const escapedRawCode = escapeHtml(code); const saveIcon = ICONS.saveSnippet || '💾'; const editIcon = ICONS.edit || '✏️'; const explainIcon = ICONS.explain || '❓'; const refactorIcon = ICONS.refactor || '✨'; const bugIcon = ICONS.bug || '🐞'; const optimizeIcon = ICONS.optimize || '⚡'; const documentIcon = ICONS.document || '📄'; const useIcon = ICONS.use || '⬆️'; const copyIcon = ICONS.copy || '📋'; const playIcon = ICONS.play || '▶️'; const saveButtonHtml = `<button class="code-block-button save-snippet-button" title="Save Snippet" data-lang="${language}" data-code="${escapedRawCode}">${saveIcon}</button>`; const editButtonHtml = `<button class="code-block-button edit-code-button" title="Edit Code" data-lang="${language}" data-code="${escapedRawCode}">${editIcon}</button>`; const explainButtonHtml = `<button class="code-block-button action-explain-button" title="Explain Code" data-lang="${language}" data-code="${escapedRawCode}">${explainIcon}</button>`; const refactorButtonHtml = `<button class="code-block-button action-refactor-button" title="Refactor Code" data-lang="${language}" data-code="${escapedRawCode}">${refactorIcon}</button>`; const findBugsButtonHtml = `<button class="code-block-button action-find-bugs-button" title="Find Bugs" data-lang="${language}" data-code="${escapedRawCode}">${bugIcon}</button>`; const optimizeButtonHtml = `<button class="code-block-button action-optimize-button" title="Optimize Code" data-lang="${language}" data-code="${escapedRawCode}">${optimizeIcon}</button>`; const documentButtonHtml = `<button class="code-block-button action-document-button" title="Add Docs/Comments" data-lang="${language}" data-code="${escapedRawCode}">${documentIcon}</button>`; const useButtonHtml = `<button class="code-block-button use-code-button" title="Use Code in Input" data-code="${escapedRawCode}">${useIcon}</button>`; const copyButtonHtml = `<button class="code-block-button code-copy-button" title="Copy Code" data-code="${escapedRawCode}">${copyIcon}</button>`; const playButtonHtml = `<button class="code-block-button play-code-button" title="Play Code Snippet (TTS)" data-code="${escapedRawCode}">${playIcon}</button>`; const actionsBarHtml = `<div class="code-block-actions">${playButtonHtml}<span class="action-divider"></span>${explainButtonHtml}${refactorButtonHtml}${findBugsButtonHtml}${optimizeButtonHtml}${documentButtonHtml}<span class="action-divider"></span>${saveButtonHtml}${editButtonHtml}${useButtonHtml}${copyButtonHtml}</div>`; const inlineEditorHtml = ` <div class="inline-editor-container"> <textarea class="inline-code-textarea" spellcheck="false" data-lang="${language}">${escapedCode}</textarea> <div class="inline-editor-actions"> <button class="inline-editor-button cancel inline-cancel-button">Cancel</button> <button class="inline-editor-button save inline-save-button">Save</button> </div> </div>`; const languageLabelHtml = `<span class="code-language-label">${language}</span>`; resultHtml += `<div class="code-block-wrapper"> ${languageLabelHtml} <pre class="${languageClass}"><code class="${languageClass}">${escapedCode}</code></pre> ${inlineEditorHtml} ${actionsBarHtml} </div>`; lastIndex = offset + match.length; return ''; }); resultHtml += escapeHtml(cleanedText.substring(lastIndex)).replace(/\n/g, '<br>'); } catch (e) { console.error("Error processing message content:", e); return escapeHtml(cleanedText || '').replace(/\n/g, '<br>'); } return resultHtml; }
            function displayMessage(rawText, isUser, isThinking = false, isError = false) { if (isUser) { console.log("Displaying user message:", rawText); } const pairDiv = document.createElement('div'); pairDiv.className = 'message-pair'; let msgEl; try { if (isUser) { msgEl = document.createElement('p'); msgEl.className = 'user-message'; const sourceLabel = (currentSource === BACKEND_SOURCE_VALUE) ? '[Web] ' : ''; msgEl.innerHTML = `<span class="message-label">You:</span>${sourceLabel}${escapeHtml(rawText).replace(/\n/g, '<br>')}`; } else { msgEl = document.createElement('p'); const aiLabel = (currentSource === BACKEND_SOURCE_VALUE) ? 'orbe (Web)' : 'orbe'; if (isThinking) { msgEl.className = 'thinking-message'; msgEl.innerHTML = `<span class="message-label">${aiLabel}:</span>...`; } else { msgEl.className = isError ? 'orbe-message error' : 'orbe-message'; const processedHtml = processMessageContent(rawText, isError); msgEl.innerHTML = `<span class="message-label">${aiLabel}${isError?'(Err)':''}:</span>${isError?'<i>':''}${processedHtml}${isError?'</i>':''}`; if (!isError && rawText.trim().length > 0 && !msgEl.querySelector('.code-block-wrapper')) { msgEl.appendChild(createCopyButton(rawText)); } if (!isError && typeof Prism !== 'undefined') { requestAnimationFrame(() => { if (msgEl?.parentNode) Prism.highlightAllUnder(msgEl); }); } } } pairDiv.appendChild(msgEl); chatDisplayArea.appendChild(pairDiv); scrollToBottom(); } catch (e) { console.error("Error displaying message:", e); } return isUser ? null : msgEl; }
            function updateParameterDisplay() { if (temperatureControl && temperatureValue) temperatureValue.textContent = parseFloat(temperatureControl.value).toFixed(2); if (topPControl && topPValue) topPValue.textContent = parseFloat(topPControl.value).toFixed(2); if (topKControl && topKValue) topKValue.textContent = topKControl.value; if (repeatPenaltyControl && repeatPenaltyValue) repeatPenaltyValue.textContent = parseFloat(repeatPenaltyControl.value).toFixed(2); if (seedControl && seedValue) seedValue.textContent = seedControl.value; if (numCtxControl && numCtxValue) numCtxValue.textContent = numCtxControl.value; if (paramGrid) { paramGrid.querySelectorAll('input[data-param]').forEach(input => { const key = input.dataset.param; let value = input.type === 'number' || input.type === 'range' ? parseFloat(input.value) : input.value; if (input.type === 'number' && input.step === '1') value = parseInt(input.value, 10); if (key === 'stop') value = input.value.split(',').map(s => s.trim()).filter(s => s); if (!isNaN(value) || typeof value === 'string' || Array.isArray(value)) { generationParams[key] = value; } }); const defaults = getDefaultParams(); for (const key in defaults) { if (!(key in generationParams)) generationParams[key] = defaults[key]; } } }
            function handleParamChange(event) { const target = event.target; if (target && target.dataset.param) { const param = target.dataset.param; const value = target.value; const displayValue = target.type === 'range' ? parseFloat(value).toFixed(2) : value; const valueElement = getElem(`${param}Value`, false); if (valueElement) { valueElement.textContent = displayValue; } let parsedValue = target.type === 'number' || target.type === 'range' ? parseFloat(value) : value; if (target.type === 'number' && target.step === '1') parsedValue = parseInt(value, 10); if (param === 'stop') parsedValue = value.split(',').map(s => s.trim()).filter(s => s); if (!isNaN(parsedValue) || typeof parsedValue === 'string' || Array.isArray(parsedValue)) { generationParams[param] = parsedValue; } if (event.type === 'change') saveSettings(); } }
            function getDefaultParams() { return { temperature: 1.0, top_p: 0.9, top_k: 40, repeat_penalty: 1.1, seed: 0, num_ctx: 0, stop: [] }; }
            function resetParameters() { const defaultParams = getDefaultParams(); generationParams = { ...defaultParams }; if(temperatureControl) temperatureControl.value = defaultParams.temperature; if(temperatureValue) temperatureValue.textContent = defaultParams.temperature.toFixed(2); if(topPControl) topPControl.value = defaultParams.top_p; if(topPValue) topPValue.textContent = defaultParams.top_p.toFixed(2); if(topKControl) topKControl.value = defaultParams.top_k; if(topKValue) topKValue.textContent = defaultParams.top_k; if(repeatPenaltyControl) repeatPenaltyControl.value = defaultParams.repeat_penalty; if(repeatPenaltyValue) repeatPenaltyValue.textContent = defaultParams.repeat_penalty.toFixed(2); if(seedControl) seedControl.value = defaultParams.seed; if(seedValue) seedValue.textContent = defaultParams.seed; if(numCtxControl) numCtxControl.value = defaultParams.num_ctx; if(numCtxValue) numCtxValue.textContent = defaultParams.num_ctx; if(stopControl) stopControl.value = (defaultParams.stop || []).join(','); console.log("Parameters reset to defaults."); saveSettings(); }
            function openModal(modalElement) { if (modalElement) { modalElement.style.display = 'flex'; document.body.classList.add('modal-open'); } else { console.error("Attempted to open a non-existent modal"); } } function closeModal(modalElement) { if (modalElement) { modalElement.style.display = 'none'; document.body.classList.remove('modal-open'); } }
            function cancelInlineEdit(wrapper = null) { const targetWrapper = wrapper || currentEditingBlockWrapper; if (targetWrapper) { targetWrapper.classList.remove('editing'); } currentEditingBlockWrapper = null; }
            function startInlineEdit(editButton) { const wrapper = editButton.closest('.code-block-wrapper'); if (!wrapper) return; if (currentEditingBlockWrapper && currentEditingBlockWrapper !== wrapper) { cancelInlineEdit(); } currentEditingBlockWrapper = wrapper; const pre = wrapper.querySelector('pre'); const textarea = wrapper.querySelector('textarea.inline-code-textarea'); if(!pre || !textarea) return; const code = pre.textContent; textarea.value = code; wrapper.classList.add('editing'); adjustInlineTextareaHeight(textarea); textarea.focus(); textarea.selectionStart = textarea.selectionEnd = textarea.value.length; }
            function saveInlineEdit(saveButton) { const wrapper = saveButton.closest('.code-block-wrapper'); if (!wrapper) return; const textarea = wrapper.querySelector('textarea.inline-code-textarea'); const pre = wrapper.querySelector('pre'); const codeElement = pre?.querySelector('code'); if(!textarea || !pre || !codeElement) return; const newCode = textarea.value; codeElement.textContent = newCode; wrapper.querySelectorAll('.code-block-button').forEach(btn => { if (btn.dataset.code !== undefined) { btn.dataset.code = newCode; } }); cancelInlineEdit(wrapper); if (typeof Prism !== 'undefined') { requestAnimationFrame(() => Prism.highlightElement(codeElement)); } }
            function openSystemPromptEditor() { systemPromptTextarea.value = currentSystemPrompt || MODE_PROMPTS[selectedMode] || MODE_PROMPTS['default']; openModal(systemPromptModal); }
            function closeSystemPromptEditor() { closeModal(systemPromptModal); }
            function saveSystemPrompt() { currentSystemPrompt = systemPromptTextarea.value.trim(); selectedMode = 'custom'; let customOption = modeSelector.querySelector('option[value="custom"]'); if (customOption) { customOption.hidden = false; customOption.disabled = false; modeSelector.value = 'custom'; } else { console.warn("Custom mode option not found in selector."); } closeSystemPromptEditor(); saveSettings(); console.log("Custom system prompt saved."); }
            async function showModelInfo() { if (!currentSource || currentSource === BACKEND_SOURCE_VALUE) return; const baseUrl = localStorage.getItem('ollamaApiUrl') || OLLAMA_API_BASE; modelInfoTitle.textContent = `Info: ${currentSource}`; modelInfoBody.innerHTML = '<pre>Loading details...</pre>'; openModal(modelInfoModal); try { const response = await fetch(`${baseUrl}/api/show`, { method: 'POST', mode: 'cors', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name: currentSource }) }); if (!response.ok) throw new Error(`Ollama API error (${response.status})`); const data = await response.json(); let formattedJson = JSON.stringify(data, null, 2); modelInfoBody.innerHTML = `<pre>${escapeHtml(formattedJson)}</pre>`; } catch (error) { console.error("Error fetching model info:", error); modelInfoBody.innerHTML = `<pre>Error loading details: ${escapeHtml(error.message)}</pre>`; } }
            function closeModelInfo() { closeModal(modelInfoModal); }
            async function deleteOllamaModel(event) { if (!currentSource || currentSource === BACKEND_SOURCE_VALUE) return; if (!confirm(`Are you sure you want to permanently delete the model "${currentSource}" from Ollama? This cannot be undone.`)) return; const baseUrl = localStorage.getItem('ollamaApiUrl') || OLLAMA_API_BASE; console.log(`Attempting to delete model: ${currentSource}`); event.target.disabled = true; event.target.textContent = "Deleting..."; try { const response = await fetch(`${baseUrl}/api/delete`, { method: 'DELETE', mode: 'cors', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name: currentSource }) }); if (!response.ok) { let errorText = await response.text(); throw new Error(`Ollama API error (${response.status}): ${errorText}`); } console.log(`Model ${currentSource} deleted successfully.`); closeModal(modelInfoModal); await fetchAndPopulateModels(); } catch (error) { console.error("Error deleting model:", error); alert(`Failed to delete model: ${error.message}`); } finally { event.target.disabled = false; event.target.textContent = "Delete Model"; } }
            function loadPresets() { try { const stored = localStorage.getItem(PRESET_STORAGE_KEY); presets = stored ? JSON.parse(stored) : []; console.log(`Loaded ${presets.length} presets.`); } catch (e) { console.error("Failed to load presets:", e); presets = []; } } function savePresets(presetsToSave) { try { localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presetsToSave)); } catch (e) { console.error("Could not save presets:", e); alert("Could not save presets."); } }
            function populatePresetSelector() { if(!presetSelector) return; presetSelector.innerHTML = '<option value="">Load Preset...</option>'; presets.sort((a, b) => a.name.localeCompare(b.name)); presets.forEach(preset => { const option = document.createElement('option'); option.value = preset.name; option.textContent = preset.name; presetSelector.appendChild(option); }); if(deletePresetButton) deletePresetButton.disabled = true; }
            function saveCurrentPreset() { const name = prompt("Enter a name for this preset:", "My Preset"); if (!name || !name.trim()) return; const preset = { name: name.trim(), source: currentSource, mode: selectedMode, system: (selectedMode === 'custom') ? currentSystemPrompt : '', options: { ...generationParams } }; let existingIndex = presets.findIndex(p => p.name.toLowerCase() === preset.name.toLowerCase()); if (existingIndex !== -1) { if (confirm(`Preset "${preset.name}" already exists. Overwrite?`)) { presets[existingIndex] = preset; } else { return; } } else { presets.push(preset); } savePresets(presets); populatePresetSelector(); presetSelector.value = preset.name; if(deletePresetButton) deletePresetButton.disabled = false; console.log(`Preset "${preset.name}" saved.`); }
            function loadSelectedPreset() { const selectedName = presetSelector.value; if (!selectedName) { if(deletePresetButton) deletePresetButton.disabled = true; return; } const preset = presets.find(p => p.name === selectedName); if (!preset) { alert("Selected preset not found!"); if(deletePresetButton) deletePresetButton.disabled = true; return; } console.log(`Loading preset: ${preset.name}`); if (modelSelector.querySelector(`option[value="${preset.source}"]`)) { modelSelector.value = preset.source; currentSource = preset.source; } else { console.warn(`Preset source "${preset.source}" not found. Keeping current source: ${currentSource}.`); } selectedMode = preset.mode || 'default'; modeSelector.value = selectedMode; if (selectedMode === 'custom') { currentSystemPrompt = preset.system || ""; let customOption = modeSelector.querySelector('option[value="custom"]'); if (customOption) { customOption.hidden = false; customOption.disabled = false; modeSelector.value = 'custom'; } } else { currentSystemPrompt = MODE_PROMPTS[selectedMode] || MODE_PROMPTS['default']; let customOption = modeSelector.querySelector('option[value="custom"]'); if (customOption) customOption.hidden = true; } generationParams = { ...getDefaultParams(), ...(preset.options || {}) }; updateParameterDisplay(); if(deletePresetButton) deletePresetButton.disabled = false; updateUiForSource(); saveSettings(); }
            function deleteSelectedPreset() { const selectedName = presetSelector.value; if (!selectedName) return; if (!confirm(`Are you sure you want to delete the preset "${selectedName}"?`)) return; presets = presets.filter(p => p.name !== selectedName); savePresets(presets); populatePresetSelector(); resetParameters(); console.log(`Preset "${selectedName}" deleted.`); }
            function exportPresets() { if (presets.length === 0) { alert("No presets to export."); return; } const filename = `orbe_presets_${new Date().toISOString().split('T')[0]}.json`; const jsonString = JSON.stringify(presets, null, 2); triggerTextFileDownload(jsonString, filename); }
            function triggerImportPresets() { importPresetsInput.click(); }
            function importPresets(event) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { try { const importedPresets = JSON.parse(e.target.result); if (!Array.isArray(importedPresets)) throw new Error("Imported file is not a valid preset array."); let added = 0, updated = 0; importedPresets.forEach(imported => { if (imported && imported.name && imported.options) { let existingIndex = presets.findIndex(p => p.name.toLowerCase() === imported.name.toLowerCase()); if (existingIndex !== -1) { if (confirm(`Preset "${imported.name}" already exists. Overwrite?`)) { presets[existingIndex] = imported; updated++; } } else { presets.push(imported); added++; } } else { console.warn("Skipping invalid preset object during import:", imported); } }); savePresets(presets); populatePresetSelector(); alert(`Presets imported: ${added} added, ${updated} updated.`); } catch (error) { console.error("Error importing presets:", error); alert(`Failed to import presets: ${error.message}`); } finally { importPresetsInput.value = null; } }; reader.onerror = () => alert("Error reading preset file."); reader.readAsText(file); }
            function updateTtsButtonState() { if (!ttsToggleButton || !ttsIcon || !ttsLabel) return; if (isTtsEnabled) { ttsToggleButton.classList.add('tts-enabled'); ttsIcon.setAttribute('data-feather', 'volume-2'); ttsLabel.textContent = 'TTS On'; ttsToggleButton.title = 'Disable Speech Output'; } else { ttsToggleButton.classList.remove('tts-enabled'); ttsIcon.setAttribute('data-feather', 'volume-x'); ttsLabel.textContent = 'TTS Off'; ttsToggleButton.title = 'Enable Speech Output'; } try { if (typeof feather !== 'undefined' && feather) feather.replace({ 'stroke-width': 1.8 }); } catch (e) { console.warn("Feather replace error in updateTtsButtonState", e); } }
            function saveSettings() { try { const settings = { selectedSource: currentSource, selectedMode: selectedMode, systemPrompt: currentSystemPrompt, generationParams: generationParams, isTtsEnabled: isTtsEnabled, selectedVoiceName: selectedVoice?.name || null, ttsRateIndex: currentRateIndex }; localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings)); /* console.log("Settings saved."); */ } catch (e) { console.error("Failed to save settings:", e); } }
            function loadSettings() { try { const stored = localStorage.getItem(SETTINGS_STORAGE_KEY); if (stored) { const settings = JSON.parse(stored); console.log("Loading saved settings..."); currentSource = settings.selectedSource || ''; selectedMode = settings.selectedMode || 'chat'; if (modeSelector) modeSelector.value = selectedMode; currentSystemPrompt = settings.systemPrompt || ''; generationParams = { ...getDefaultParams(), ...(settings.generationParams || {}) }; updateParameterDisplay(); isTtsEnabled = settings.isTtsEnabled || false; currentRateIndex = settings.ttsRateIndex || 0; if (settings.selectedVoiceName && availableVoices.length > 0) { selectedVoice = availableVoices.find(v => v.name === settings.selectedVoiceName) || null; const voiceIndex = availableVoices.findIndex(v => v.name === selectedVoice?.name); if (voiceSelector) voiceSelector.value = (voiceIndex !== -1) ? voiceIndex : 'default'; } else { if (voiceSelector) voiceSelector.value = 'default'; selectedVoice = null; } updateTtsButtonState(); } else { currentSystemPrompt = MODE_PROMPTS[selectedMode] || MODE_PROMPTS['default']; generationParams = getDefaultParams(); updateParameterDisplay(); updateTtsButtonState(); } } catch (e) { console.error("Failed to load settings:", e); generationParams = getDefaultParams(); updateParameterDisplay(); updateTtsButtonState(); } }
            function saveLastSubmission(prompt, context, source, options) { lastSubmission = { prompt, context, source, options: {...options} }; if(regenerateButton) regenerateButton.style.display = 'inline-flex'; } function regenerateLastResponse() { if (!lastSubmission.prompt) { alert("No previous submission found to regenerate."); return; } console.log("Regenerating last response..."); displayMessage(lastSubmission.prompt, true); askQuestionInternal(lastSubmission.prompt, lastSubmission.context, lastSubmission.source, lastSubmission.options); } function clearChatContext() { chatHistory = []; console.log("Context cleared (chat history for context removed)."); if (systemInfo) { systemInfo.textContent = "Context Cleared"; systemInfo.style.color = "#aaa"; systemInfo.style.opacity = '1'; setTimeout(() => { systemInfo.style.opacity = '0'; }, 3000); } }
            function createParamInfoTooltip() { paramInfoTooltip = document.createElement('div'); paramInfoTooltip.id = 'paramInfoTooltip'; document.body.appendChild(paramInfoTooltip); paramInfoTooltip.addEventListener('mouseover', () => { if(currentInfoButton) paramInfoTooltip.style.display = 'block'; }); paramInfoTooltip.addEventListener('mouseout', (e) => { if(!e.relatedTarget || !e.relatedTarget.closest('#paramInfoTooltip')) hideParamInfoTooltip(); }); } function showParamInfoTooltip(button) { if (!paramInfoTooltip) createParamInfoTooltip(); const paramKey = button.dataset.paramInfo; const infoText = PARAM_INFO_TEXT[paramKey]; if (!infoText) return; paramInfoTooltip.innerHTML = infoText; const buttonRect = button.getBoundingClientRect(); paramInfoTooltip.style.display = 'block'; paramInfoTooltip.style.left = `${buttonRect.left + window.scrollX}px`; paramInfoTooltip.style.top = `${buttonRect.bottom + window.scrollY + 5}px`; currentInfoButton = button; } function hideParamInfoTooltip() { if (paramInfoTooltip) paramInfoTooltip.style.display = 'none'; currentInfoButton = null; }
            function exportChat() { if (chatHistory.length === 0) { alert("No chat history to export."); return; } try { const filename = `orbe_chat_${new Date().toISOString().split('T')[0]}.json`; const jsonString = JSON.stringify(chatHistory.map(e => ({...e, timestamp: e.timestamp.toISOString()})), null, 2); triggerTextFileDownload(jsonString, filename); } catch(e) { console.error("Error exporting chat:", e); alert("Failed to export chat history."); } } function triggerImportChats() { importChatsInput.click(); }
            function importChats(event) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { try { const importedHistory = JSON.parse(e.target.result); if (!Array.isArray(importedHistory)) throw new Error("Imported file is not a valid chat history array."); if (confirm(`Replace current chat history (${chatHistory.length} messages) with imported history (${importedHistory.length} messages)?`)) { chatHistory = importedHistory.map(item => ({ ...item, timestamp: item.timestamp ? new Date(item.timestamp) : new Date() })); saveChatHistory(); renderChatHistory(); lastSubmission = {}; if (regenerateButton) regenerateButton.style.display = 'none'; alert(`Chat history imported successfully.`); } } catch (error) { console.error("Error importing chat history:", error); alert(`Failed to import chat history: ${error.message}`); } finally { importChatsInput.value = null; } }; reader.onerror = () => alert("Error reading chat history file."); reader.readAsText(file); }
            function triggerAttachFile() { console.log("triggerAttachFile called"); if (attachFileInput) attachFileInput.click(); }
            function handleFileAttach(event) { console.log("handleFileAttach called"); const file = event.target.files[0]; if (!file) return; const fileSizeMB = file.size / 1024 / 1024; if (fileSizeMB > MAX_ATTACHMENT_SIZE_MB) { alert(`File is too large (${fileSizeMB.toFixed(1)}MB). Max: ${MAX_ATTACHMENT_SIZE_MB}MB.`); clearAttachment(); return; } const reader = new FileReader(); reader.onload = (e) => { attachedFileContent = e.target.result; attachedFileDetails = { name: file.name, type: file.type }; if (attachedFileName) attachedFileName.textContent = file.name; if (attachmentDisplay) attachmentDisplay.style.display = 'inline-flex'; console.log(`Attached file: ${file.name}, size: ${file.size} bytes`); }; reader.onerror = (e) => { alert("Error reading file."); console.error("File reading error:", e); clearAttachment(); }; reader.readAsText(file); event.target.value = null; }
            function clearAttachment() { attachedFileContent = null; attachedFileDetails = null; if (attachedFileName) attachedFileName.textContent = ''; if (attachmentDisplay) attachmentDisplay.style.display = 'none'; if (attachFileInput) attachFileInput.value = null; console.log("Attachment cleared."); }
            function saveChatHistory() { try { localStorage.setItem(CHAT_HISTORY_STORAGE_KEY, JSON.stringify(chatHistory)); } catch (e) { console.error("Failed to save chat history:", e); } }
            function loadChatHistory() { try { const storedHistory = localStorage.getItem(CHAT_HISTORY_STORAGE_KEY); if (storedHistory) { chatHistory = JSON.parse(storedHistory).map(item => ({ ...item, timestamp: item.timestamp ? new Date(item.timestamp) : new Date() })); console.log(`Loaded ${chatHistory.length} messages from storage.`); } else { chatHistory = []; } } catch (e) { console.error("Failed to load chat history, starting fresh:", e); chatHistory = []; } }
            function renderChatHistory() { chatDisplayArea.innerHTML = ''; chatHistory.forEach(entry => { displayMessage(entry.question, true); displayMessage(entry.answer, false, false, entry.isError || false); }); scrollToBottom(); }
            function handleAudioFilesSelected(event) { console.log("Files selected:", event.target.files); const files = event.target.files; if (!files.length || !playlistDisplay) return; const noTracksMsg = playlistDisplay.querySelector('.no-tracks'); if (noTracksMsg) playlistDisplay.innerHTML = ''; for (let i = 0; i < files.length; i++) { const file = files[i]; if (file.type.startsWith('audio/')) { const trackInfo = { file: file, title: file.name.replace(/\.[^/.]+$/, ""), howl: null }; playlist.push(trackInfo); addTrackToPlaylistUI(trackInfo, playlist.length - 1); } else { console.warn(`Skipping non-audio file: ${file.name}`); } } event.target.value = null; }
            function addTrackToPlaylistUI(trackInfo, index) { const li = document.createElement('li'); li.dataset.index = index; const titleSpan = document.createElement('span'); titleSpan.className = 'playlist-track-title'; titleSpan.textContent = trackInfo.title; li.appendChild(titleSpan); const removeBtn = document.createElement('button'); removeBtn.className = 'remove-track-btn'; removeBtn.innerHTML = '&times;'; removeBtn.title = 'Remove Track'; removeBtn.dataset.index = index; removeBtn.onclick = (e) => { e.stopPropagation(); removeTrack(index); }; li.appendChild(removeBtn); playlistDisplay.appendChild(li); }
            function removeTrack(indexToRemove) { if (indexToRemove < 0 || indexToRemove >= playlist.length) return; console.log(`Removing track at index: ${indexToRemove}`); const trackInfo = playlist[indexToRemove]; if (indexToRemove === currentTrackIndex) { if (currentHowl) { currentHowl.stop(); currentHowl.unload(); } currentHowl = null; currentTrackIndex = -1; updateTrackDisplay("No Track Loaded", 0, 0); updatePlayPauseButton(false); } if (trackInfo.howl?._src && trackInfo.howl._src.startsWith('blob:')) { URL.revokeObjectURL(trackInfo.howl._src); } playlist.splice(indexToRemove, 1); if (currentTrackIndex > indexToRemove) { currentTrackIndex--; } renderPlaylistUI(); }
            function renderPlaylistUI() { if (!playlistDisplay) return; const playingIndex = currentTrackIndex; playlistDisplay.innerHTML = ''; if (playlist.length === 0) { playlistDisplay.innerHTML = '<li class="no-tracks">No tracks loaded.</li>'; } else { playlist.forEach((trackInfo, index) => { addTrackToPlaylistUI(trackInfo, index); }); if (playingIndex !== -1 && playingIndex < playlist.length) { const playingLi = playlistDisplay.querySelector(`li[data-index="${playingIndex}"]`); if (playingLi) playingLi.classList.add('playing'); } else { updatePlayPauseButton(false); updateTrackDisplay("No Track Loaded", 0, 0); } } }
            function handlePlaylistClick(event) { const targetLi = event.target.closest('li'); if (event.target.classList.contains('remove-track-btn')) return; if (targetLi && targetLi.dataset.index && !targetLi.classList.contains('no-tracks')) { const index = parseInt(targetLi.dataset.index, 10); if (!isNaN(index)) { console.log("Playlist item clicked:", index); playTrack(index); } } }
            function playTrack(index) { if (index < 0 || index >= playlist.length) { console.error("Invalid track index:", index); return; } if (currentHowl) { console.log("Stopping previous track."); currentHowl.stop(); if (currentHowl._src && currentHowl._src.startsWith('blob:')) { URL.revokeObjectURL(currentHowl._src); console.log("Revoked old object URL"); } currentHowl.unload(); } currentTrackIndex = index; const trackInfo = playlist[currentTrackIndex]; console.log("Attempting to play track:", trackInfo.title); try { const objectURL = URL.createObjectURL(trackInfo.file); console.log("Created object URL:", objectURL); trackInfo.howl = new Howl({ src: [objectURL], html5: true, volume: parseFloat(volumeSlider?.value ?? 0.8), format: [trackInfo.file.type.split('/')[1] || 'mp3'], onload: function() { console.log(`Track loaded: ${trackInfo.title}`); updateTrackDisplay(trackInfo.title, this.duration()); URL.revokeObjectURL(objectURL); }, onplay: function() { console.log(`Playback started: ${trackInfo.title}`); updatePlayPauseButton(true); updatePlaylistUI(); requestAnimationFrame(updateSeek); }, onpause: function() { console.log(`Playback paused: ${trackInfo.title}`); updatePlayPauseButton(false); }, onstop: function() { console.log(`Playback stopped: ${trackInfo.title}`); updatePlayPauseButton(false); updateTrackDisplay(trackInfo.title, this.duration(), 0); if (this._src && this._src.startsWith('blob:')) { URL.revokeObjectURL(this._src); console.log("Revoked object URL on stop"); } }, onend: function() { console.log(`Track ended: ${trackInfo.title}`); updatePlayPauseButton(false); if (this._src && this._src.startsWith('blob:')) { URL.revokeObjectURL(this._src); console.log("Revoked object URL on end"); } trackInfo.howl = null; playNextTrack(); }, onloaderror: function(id, err) { console.error(`Howler load error for ${trackInfo.title}:`, err); URL.revokeObjectURL(objectURL); alert(`Error loading track: ${trackInfo.title}`); }, onplayerror: function(id, err) { console.error(`Howler play error for ${trackInfo.title}:`, err); alert(`Error playing track: ${trackInfo.title}`); updatePlayPauseButton(false); } }); currentHowl = trackInfo.howl; currentHowl.play(); } catch (error) { console.error("Error creating/playing Howl:", error); updatePlayPauseButton(false); }}
            function togglePlayPause() { console.log("Toggle Play/Pause"); if (!currentHowl) { if (playlist.length > 0) { playTrack(0); } return; } if (currentHowl.playing()) { currentHowl.pause(); } else { currentHowl.play(); } }
            function stopPlayback() { console.log("Internal Stop Playback"); if (currentHowl) { currentHowl.stop(); } currentHowl = null; currentTrackIndex = -1; updatePlaylistUI(); updateTrackDisplay("No Track Loaded", 0, 0); }
            function playNextTrack() { console.log("Play Next Track"); let nextIndex = currentTrackIndex + 1; if (nextIndex >= playlist.length) { nextIndex = 0; } if (playlist.length > 0) { playTrack(nextIndex); } else { stopPlayback(); } }
            function playPreviousTrack() { console.log("Play Previous Track"); let prevIndex = currentTrackIndex - 1; if (prevIndex < 0) { prevIndex = playlist.length - 1; } if (playlist.length > 0) { playTrack(prevIndex); } else { stopPlayback(); } }
            function handleVolumeChange(event) { const volume = parseFloat(event.target.value); Howler.volume(volume); }
            function formatTime(secs = 0) { const m = Math.floor(secs/60)||0; const s=Math.floor(secs%60)||0; return `${m}:${s<10?'0':''}${s}`; }
            function updateTrackDisplay(title, duration = 0, seek = null) { if(trackNameEl) trackNameEl.textContent = title || "No Track Loaded"; if(trackTimeEl) { const currentSeek = (seek !== null) ? seek : (currentHowl?.seek() || 0); trackTimeEl.textContent = `${formatTime(currentSeek)} / ${formatTime(duration)}`; } }
            function updateSeek() { if (!currentHowl || !currentHowl.playing()) return; const seek = currentHowl.seek() || 0; const duration = currentHowl.duration() || 0; updateTrackDisplay(playlist[currentTrackIndex]?.title, duration, seek); requestAnimationFrame(updateSeek); }
            function updatePlaylistUI() { if (!playlistDisplay) return; const playlistItems = playlistDisplay.querySelectorAll('li'); playlistItems.forEach((item, index) => { item.classList.toggle('playing', index === currentTrackIndex); }); }
            function updatePlayPauseButton(isPlaying) { const icon = playPausePlayerButton?.querySelector('i'); if (!icon) return; icon.setAttribute('data-feather', isPlaying ? 'pause' : 'play'); if (typeof feather !== 'undefined') feather.replace({ 'stroke-width': 1.8, width: 14, height: 14 }); }
            function setupOrbCanvas() { if (!orbCanvas || !orbShapeDiv) return false; const size = Math.min(orbShapeDiv.offsetWidth, orbShapeDiv.offsetHeight); orbCanvas.width = size; orbCanvas.height = size; return true; }
            class OrbParticle { constructor(canvas){ this.canvas = canvas; if (!this.canvas) return; this.reset(); } reset(){ if(!this.canvas)return;const s=this.canvas.width;const a=Math.random()*Math.PI*2;const r=Math.random()*s*0.15;this.x=s/2+r*Math.cos(a);this.y=s/2+r*Math.sin(a);this.vx=(Math.random()-0.5)*ORB_SPEED_VAR;this.vy=(Math.random()-0.5)*ORB_SPEED_VAR;this.size=ORB_SIZE_BASE+Math.random()*ORB_SIZE_VAR;this.alpha=ORB_ALPHA_BASE+Math.random()*ORB_ALPHA_VAR;this.initialAlpha=this.alpha;this.hue=targetOrbHue+(Math.random()-0.5)*ORB_HUE_VAR;this.life=0;this.maxLife=250+Math.random()*150;this.waveOffsetX=Math.random()*Math.PI*2;this.waveOffsetY=Math.random()*Math.PI*2;} draw(ctx){if(!this.canvas||this.alpha<=0)return;ctx.fillStyle=`hsla(${this.hue%360},80%,70%,${this.alpha})`;ctx.beginPath();ctx.arc(this.x,this.y,this.size,0,Math.PI*2);ctx.fill();} update(time){if(!this.canvas)return;const s=this.canvas.width;const cX=s/2;const cY=s/2;let shaking=(orbAnimationMode==='thinking');const dx=this.x-cX;const dy=this.y-cY;const dSq=dx*dx+dy*dy;const dist=Math.sqrt(dSq)+0.01;let tVX=0;let tVY=0;if(orbAnimationMode==='thinking'){const swirl=ORB_SWIRL_THINKING*(1-dist/(s*0.5));tVX+=-dy/dist*swirl;tVY+=dx/dist*swirl;tVX+=dx*ORB_CENTER_PULL_THINKING;tVY+=dy*ORB_CENTER_PULL_THINKING;}else if(orbAnimationMode==='speaking'){tVX+=Math.sin(this.y*ORB_WAVE_FREQ_SPEAKING*0.8+time*ORB_WAVE_SPEED_SPEAKING+this.waveOffsetX)*ORB_WAVE_AMP_SPEAKING;tVY+=Math.cos(this.x*ORB_WAVE_FREQ_SPEAKING*0.8+time*ORB_WAVE_SPEED_SPEAKING+this.waveOffsetY)*ORB_WAVE_AMP_SPEAKING;if(dist>0){tVX+=dx/dist*ORB_EXPANSION_FORCE*1.5;tVY+=dy/dist*ORB_EXPANSION_FORCE*1.5;}}else{const swirl=ORB_SWIRL_RELAXED*(1-dist/(s*0.7));tVX+=-dy/dist*swirl;tVY+=dx/dist*swirl;if(dist>0){tVX+=dx/dist*ORB_EXPANSION_FORCE;tVY+=dy/dist*ORB_EXPANSION_FORCE;}if(dist<ORB_BOUNCE_THRESHOLD){const angle=Math.atan2(dy,dx);tVX+=Math.cos(angle)*ORB_BOUNCE_FORCE;tVY+=Math.sin(angle)*ORB_BOUNCE_FORCE;}}this.vx+=(tVX-this.vx)*(ORB_SPEED_BASE*8);this.vy+=(tVY-this.vy)*(ORB_SPEED_BASE*8);if(shaking){this.vx+=(Math.random()-0.5)*SHAKE_INTENSITY_THINKING;this.vy+=(Math.random()-0.5)*SHAKE_INTENSITY_THINKING;}this.x+=this.vx;this.y+=this.vy;let damp=ORB_DAMPING;if(shaking)damp=0.95;this.vx*=damp;this.vy*=damp;if(this.x<0||this.x>s||this.y<0||this.y>s){this.reset();}this.life++;this.alpha=this.initialAlpha*(1-this.life/this.maxLife);if(this.life>=this.maxLife||this.alpha<=0){this.reset();}} }
            function initOrbParticles() { if (!orbCanvas || !orbCtx) return; orbParticlesArray = []; try { for(let i = 0; i < ORB_PARTICLE_COUNT; i++) orbParticlesArray.push(new OrbParticle(orbCanvas)); console.log(`Initialized ${orbParticlesArray.length} orb particles.`); } catch (e) { console.error("Error creating Orb particles:", e); orbParticlesArray = []; } }
            function animateOrbParticles(time) { if (!orbCtx || !orbCanvas || !orbParticlesArray) { orbAnimationFrameId = requestAnimationFrame(animateOrbParticles); return; } try { orbCtx.clearRect(0, 0, orbCanvas.width, orbCanvas.height); targetOrbHue = (targetOrbHue + 0.05) % 360; orbParticlesArray.forEach(p => { p.update(time); p.draw(orbCtx); }); } catch (e) { console.error("Error in Orb animation loop:", e); orbAnimationFrameId = null; return; } orbAnimationFrameId = requestAnimationFrame(animateOrbParticles); }
            function startAnimations() { stopAnimations(); if (bgCtx && bgParticlesArray.length > 0) { bgAnimationFrameId = requestAnimationFrame(animateBgParticles); } if (orbCtx) { orbAnimationFrameId = requestAnimationFrame(animateOrbParticles); } } function stopAnimations() { if (bgAnimationFrameId) { cancelAnimationFrame(bgAnimationFrameId); bgAnimationFrameId = null; } if (orbAnimationFrameId) { cancelAnimationFrame(orbAnimationFrameId); orbAnimationFrameId = null; } }
            async function loadAndDisplaySettings() { let settings = {}; if (window.electronAPI?.getSettings) { settings = await window.electronAPI.getSettings(); console.log("Loaded settings via IPC:", settings); } else { const stored = localStorage.getItem('orbeBackendSettings'); if (stored) { try { settings = JSON.parse(stored); console.log("Loaded settings via localStorage:", settings); } catch(e){ console.error("Error parsing backend settings from localStorage", e); settings = {}; } } } const defaultOllamaUrl = OLLAMA_API_BASE; const loadedOllamaUrl = settings.ollamaApiUrl || defaultOllamaUrl; if (ollamaUrlInput) ollamaUrlInput.value = loadedOllamaUrl; if (ollamaModelInput) ollamaModelInput.value = settings.ollamaModel || ''; localStorage.setItem('ollamaApiUrl', loadedOllamaUrl); console.log(`Effective Ollama API URL set to: ${loadedOllamaUrl}`); } async function saveBackendSettings() { const settingsToSave = { ollamaApiUrl: ollamaUrlInput?.value || OLLAMA_API_BASE, ollamaModel: ollamaModelInput?.value || '' }; console.log("Saving backend settings:", settingsToSave); let saved = false; if (window.electronAPI?.saveSettings) { saved = await window.electronAPI.saveSettings(settingsToSave); } else { localStorage.setItem('orbeBackendSettings', JSON.stringify(settingsToSave)); saved = true; console.warn("Electron API not found, saving settings to localStorage."); } localStorage.setItem('ollamaApiUrl', settingsToSave.ollamaApiUrl); console.log(`Effective Ollama API URL updated to: ${settingsToSave.ollamaApiUrl}`); if (settingsSaveStatus) { settingsSaveStatus.textContent = saved ? "Saved!" : "Save Failed!"; settingsSaveStatus.style.display = 'inline'; settingsSaveStatus.style.color = saved ? '#3a7' : '#c66'; setTimeout(() => { settingsSaveStatus.style.display = 'none'; }, 2500); } }
            async function fetchAndPopulateModels() {
                if (!modelSelector) { console.error("fetchAndPopulateModels: modelSelector element not found."); return; }
                modelSelector.innerHTML = '<option value="">Loading sources...</option>';
                modelSelector.disabled = true;
                try {
                    const backendOption = document.createElement('option'); backendOption.value = BACKEND_SOURCE_VALUE; backendOption.textContent = "Orbe Web Search"; modelSelector.appendChild(backendOption);
                    let models = [];
                    const baseUrl = localStorage.getItem('ollamaApiUrl') || OLLAMA_API_BASE;
                    console.log(`Fetching models from: ${baseUrl}/api/tags`);
                    const response = await fetch(`${baseUrl}/api/tags`);
                    if (!response.ok) { if (response.status === 0 || !response.statusText) { throw new TypeError(`Failed to fetch: Network error or CORS issue. Ensure Ollama is running at ${baseUrl} and OLLAMA_ORIGINS is configured correctly.`); } else { throw new Error(`Ollama API error (${response.status}) fetching models.`); } }
                    const data = await response.json(); models = data.models || []; console.log(`Found ${models.length} Ollama models.`);
                    const knownEmbeddingModels = ['nomic-embed-text', 'mxbai-embed-large'];
                    const generationModels = models.filter(model => !knownEmbeddingModels.some(embedName => model.name.startsWith(embedName)) && !model.name.includes('embed'));
                    console.log(`Filtered down to ${generationModels.length} potential generation models.`);
                    generationModels.sort((a, b) => a.name.localeCompare(b.name));
                    generationModels.forEach(model => { const option = document.createElement('option'); option.value = model.name; option.textContent = model.name.replace(':latest', ''); option.title = `Size: ${(model.size / 1e9).toFixed(2)} GB | Modified: ${new Date(model.modified_at).toLocaleDateString()}`; modelSelector.appendChild(option); });
                    const settings = localStorage.getItem(SETTINGS_STORAGE_KEY) ? JSON.parse(localStorage.getItem(SETTINGS_STORAGE_KEY)) : {}; const savedSource = settings.selectedSource || ''; let sourceToSelect = ''; if (savedSource && modelSelector.querySelector(`option[value="${savedSource}"]`)) { sourceToSelect = savedSource; } else if (modelSelector.options.length > 1 && modelSelector.options[1].value !== BACKEND_SOURCE_VALUE) { sourceToSelect = modelSelector.options[1].value; } else if (modelSelector.options.length > 0) { sourceToSelect = modelSelector.options[0].value; } modelSelector.value = sourceToSelect; currentSource = sourceToSelect; console.log(`Model selection set to: ${currentSource}`);
                } catch (error) {
                    console.error("Error fetching or populating models:", error); modelSelector.innerHTML = `<option value="">Error loading</option>`; if (systemInfo) { systemInfo.textContent = `Error: ${error.message}`; systemInfo.style.color = 'orange'; systemInfo.style.opacity = '1'; } if (!modelSelector.querySelector(`option[value="${BACKEND_SOURCE_VALUE}"]`)) { modelSelector.innerHTML = ''; const backendOption = document.createElement('option'); backendOption.value = BACKEND_SOURCE_VALUE; backendOption.textContent = "Orbe Web Search"; modelSelector.appendChild(backendOption); modelSelector.value = BACKEND_SOURCE_VALUE; currentSource = BACKEND_SOURCE_VALUE; } else { modelSelector.value = BACKEND_SOURCE_VALUE; currentSource = BACKEND_SOURCE_VALUE; } console.log(`Model selection defaulted to: ${currentSource} due to error.`);
                } finally { modelSelector.disabled = false; updateUiForSource(); }
            }
            function updateUiForSource() { const isSearchMode = currentSource === BACKEND_SOURCE_VALUE; const ollamaElements = document.querySelectorAll('.ollama-only'); ollamaElements.forEach(el => { el.classList.toggle('search-mode-hidden', isSearchMode); }); if (questionInput) { questionInput.placeholder = isSearchMode ? "Ask or search the web..." : (currentSource ? `Ask ${currentSource.split(':')[0]}...` : "Select a source"); questionInput.disabled = !currentSource; } const paramControls = paramGrid ? paramGrid.querySelectorAll('input, select, button:not(#resetParamsButton)') : []; paramControls.forEach(control => { control.classList.toggle('search-mode-disabled', isSearchMode); }); if (topKControl) topKControl.disabled = isSearchMode; if (numCtxControl) numCtxControl.disabled = isSearchMode; if (seedControl) seedControl.disabled = isSearchMode; if (stopControl) stopControl.disabled = isSearchMode; console.log(`UI updated for source: ${currentSource}. Search mode: ${isSearchMode}`); }
            function buildContext() { if (currentSource === BACKEND_SOURCE_VALUE) { return ""; } let contextString = ""; const turnsToInclude = Math.min(chatHistory.length, MAX_CONTEXT_TURNS); if (turnsToInclude > 0) { const relevantHistory = chatHistory.filter(entry => !entry.isError).slice(-turnsToInclude); relevantHistory.forEach(entry => { contextString += `User: ${entry.question}\n\norbe: ${entry.answer}\n\n`; }); } if (attachedFileContent && attachedFileDetails) { contextString = `--- Start Attached File: ${attachedFileDetails.name} ---\n${attachedFileContent}\n--- End Attached File ---\n\n` + contextString; } return contextString; }
            function makeDraggable(panel, handle) { let isDragging = false; let startX, startY, initialX, initialY; handle.addEventListener('mousedown', (e) => { isDragging = true; startX = e.clientX; startY = e.clientY; initialX = panel.offsetLeft; initialY = panel.offsetTop; panel.style.cursor = 'grabbing'; handle.style.cursor = 'grabbing'; document.body.style.userSelect = 'none'; panel.style.position = 'absolute'; panel.style.bottom = 'auto'; panel.style.right = 'auto'; }); document.addEventListener('mousemove', (e) => { if (!isDragging) return; const currentX = e.clientX; const currentY = e.clientY; const diffX = currentX - startX; const diffY = currentY - startY; let newX = initialX + diffX; let newY = initialY + diffY; const bodyRect = document.body.getBoundingClientRect(); newX = Math.max(0, Math.min(newX, bodyRect.width - panel.offsetWidth)); newY = Math.max(0, Math.min(newY, bodyRect.height - panel.offsetHeight)); panel.style.left = `${newX}px`; panel.style.top = `${newY}px`; }); document.addEventListener('mouseup', () => { if (isDragging) { isDragging = false; panel.style.cursor = 'default'; handle.style.cursor = 'move'; document.body.style.userSelect = ''; } }); handle.addEventListener('dragstart', (e) => { e.preventDefault(); }); }
            function setupRecognitionHandlers() { if (!recognition) return; recognition.onresult = (event) => { const transcript = event.results[event.results.length - 1][0].transcript.trim(); console.log('Speech recognized:', transcript); handleRecognizedSpeech(transcript); }; recognition.onerror = (event) => { console.error('Speech recognition error:', event.error, event.message); let errorMsg = `Speech Error: ${event.error}`; if (event.error === 'no-speech') { errorMsg = 'No speech detected.'; } else if (event.error === 'audio-capture') { errorMsg = 'Mic error.'; } else if (event.error === 'not-allowed') { errorMsg = 'Mic access denied.'; } else if (event.error === 'network') { errorMsg = 'Network error for STT.';} else { errorMsg = `Speech Error: ${event.error}`; } if (systemInfo) { systemInfo.textContent = errorMsg; systemInfo.style.opacity = '1'; systemInfo.style.color = 'orange'; } stopListening(); }; recognition.onstart = () => { console.log('Speech recognition started.'); isListening = true; updateMicButtonState(true); if (systemInfo) { systemInfo.textContent = "Status: Listening..."; systemInfo.style.opacity = '1'; systemInfo.style.color = '#ccc'; } if (questionInput) questionInput.disabled = true; }; recognition.onend = () => { console.log('Speech recognition ended.'); if (isListening) { stopListening(); } }; recognition.onspeechend = () => { console.log('Speech stopped being detected.'); }; }
            function startListening() { if (!recognition || isListening || thinkingFlag) { console.warn("Cannot start listening:", { isListening, thinkingFlag, recognitionExists: !!recognition }); return; } try { if (systemInfo && (systemInfo.textContent.includes("Status:") || systemInfo.textContent.includes("Mic") || systemInfo.textContent.includes("Speech"))) { systemInfo.textContent = "Status: Ready"; systemInfo.style.opacity = '0'; } console.log("Attempting recognition.start()..."); recognition.start(); } catch (e) { console.error("Error starting recognition:", e); if (systemInfo) { systemInfo.textContent = `Mic Start Error: ${e.message}`; systemInfo.style.opacity = '1'; systemInfo.style.color = 'orange'; } stopListening(); } }
            function stopListening() { if (recognition && isListening) { try { recognition.stop(); } catch (e) { console.warn("Error stopping recognition:", e); } } isListening = false; updateMicButtonState(false); if (questionInput && !thinkingFlag) { questionInput.disabled = !currentSource; } if (systemInfo && systemInfo.textContent === "Status: Listening...") { setTimeout(() => { if (systemInfo?.textContent === "Status: Listening...") { systemInfo.textContent = "Status: Ready"; systemInfo.style.opacity = '0'; } }, 500); } }
            function updateMicButtonState(listening) { const MicButtonRef = getElem('micButton', false); if (!MicButtonRef) return; const iconElement = MicButtonRef.querySelector('i'); if (listening) { MicButtonRef.classList.add('listening'); MicButtonRef.title = "Stop Listening"; if (iconElement) iconElement.setAttribute('data-feather', 'mic-off'); } else { MicButtonRef.classList.remove('listening'); MicButtonRef.title = "Start Voice Input"; if (iconElement) iconElement.setAttribute('data-feather', 'mic'); } try { if (typeof feather !== 'undefined' && feather) feather.replace({ 'stroke-width': 1.8 }); } catch (e) {console.warn("Feather replace error in mic update", e);} }
            function handleRecognizedSpeech(transcript) { if (!transcript) return; const transcriptLower = transcript.toLowerCase(); if (transcriptLower.startsWith("save this") || transcriptLower.startsWith("save response") || transcriptLower.startsWith("save recipe") || transcriptLower.startsWith("save last message")) { console.log("Save command detected."); handleSaveCommand(); return; } console.log("Treating speech as query:", transcript); if (questionInput) { questionInput.value = transcript; adjustTextareaHeight(); } if (!thinkingFlag && currentSource) { const questionToSend = transcript; displayMessage(questionToSend, true); if(questionInput) questionInput.value = ''; adjustTextareaHeight(); const context = buildContext(); askQuestionInternal(questionToSend, context, currentSource, generationParams); } else { const reason = thinkingFlag ? "orbe is thinking" : "No source selected"; console.warn(`Cannot submit voice query: ${reason}.`); if (systemInfo) { systemInfo.textContent = `Cannot submit: ${reason}`; systemInfo.style.opacity = '1'; systemInfo.style.color='orange';} speakText(`Cannot submit query now because ${reason}.`, true); } }
            function handleSaveCommand() { if (chatHistory.length === 0) { speakText("Nothing to save yet.", true); return; } let lastOrbeAnswer = null; for (let i = chatHistory.length - 1; i >= 0; i--) { if (chatHistory[i].answer && !chatHistory[i].isError) { lastOrbeAnswer = chatHistory[i].answer; break; } } if (!lastOrbeAnswer) { speakText("Last response not found or was an error.", true); return; } const ts = new Date(); const filename = `orbe_Save_${ts.getFullYear()}${String(ts.getMonth()+1).padStart(2,'0')}${String(ts.getDate()).padStart(2,'0')}_${String(ts.getHours()).padStart(2,'0')}${String(ts.getMinutes()).padStart(2,'0')}.txt`; try { triggerTextFileDownload(lastOrbeAnswer, filename); console.log("Triggered download:", filename); speakText("Saved to downloads.", true); if (systemInfo) { systemInfo.textContent = `Saved ${filename}`; systemInfo.style.opacity = '1'; systemInfo.style.color='#3a7'; setTimeout(() => {if(systemInfo) systemInfo.style.opacity = '0';}, 3000);} } catch (error) { console.error("Error triggering download:", error); speakText("Error saving the file.", true); if (systemInfo) { systemInfo.textContent = "Error saving file."; systemInfo.style.opacity = '1'; systemInfo.style.color='orange';} } }

            // Main Application Logic
            async function askQuestionInternal(question, promptContext, source, options, isAction = false) {
                if (thinkingFlag) return;
                window.speechSynthesis.cancel(); resetTtsControls();
                isSpeaking = false; orbAnimationMode = 'thinking'; thinkingFlag = true; isGeneratingStream = true;
                showInputControls(false);
                thinkingMessageElement = displayMessage("...", false, true);
                scrollToBottom();

                let accumulatedResponse = "", isError = false, finalResponseData = null;
                currentAbortController = new AbortController();
                const baseUrl = localStorage.getItem('ollamaApiUrl') || OLLAMA_API_BASE;

                try {
                    if (source === BACKEND_SOURCE_VALUE) {
                        const apiUrl = `/api/search-and-chat`; const payload = { query: question, mode: selectedMode };
                        console.log("Sending request via Fetch to Backend:", apiUrl, payload);
                        const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify(payload), signal: currentAbortController.signal });
                        if (!response.ok || !response.body) { isError = true; let errorBody = await response.text(); try { const parsedError = JSON.parse(errorBody); errorBody = parsedError.error || errorBody; } catch(e) {} throw new Error(`Backend API error: ${response.status} - ${errorBody}`); }
                        const reader = response.body.getReader(); const decoder = new TextDecoder(); let partialLine = ""; let isFirstStreamChunk = true; const targetElement = thinkingMessageElement;
                        while (true) {
                            const { value, done } = await reader.read();
                            if (done) { isGeneratingStream = false; console.log("Backend fetch stream finished."); if (partialLine.trim()) { try { const parsed = JSON.parse(partialLine); if (parsed.response) { if (isFirstStreamChunk && targetElement) { targetElement.innerHTML = targetElement.querySelector('.message-label')?.outerHTML || ''; isFirstStreamChunk = false; } if (targetElement) { targetElement.appendChild(document.createTextNode(parsed.response)); } accumulatedResponse += parsed.response; } if (parsed.done) finalResponseData = parsed; } catch(e){ console.warn("Error parsing final partial line (fetch):", partialLine, e); } } if (isFirstStreamChunk && targetElement && targetElement.textContent.endsWith('...')) { targetElement.innerHTML = targetElement.querySelector('.message-label')?.outerHTML || ''; } break; }
                            const chunk = decoder.decode(value, { stream: true }); const lines = (partialLine + chunk).split('\n'); partialLine = lines.pop() || "";
                            for (const line of lines) { if (line.trim() === "") continue; try { const parsed = JSON.parse(line); const responseChunk = parsed.response; if (responseChunk) { if (isFirstStreamChunk && targetElement) { targetElement.innerHTML = targetElement.querySelector('.message-label')?.outerHTML || ''; isFirstStreamChunk = false; } if (targetElement) { targetElement.appendChild(document.createTextNode(responseChunk)); accumulatedResponse += responseChunk; scrollToBottom(); } } if (parsed.done) { finalResponseData = parsed; console.log("Backend 'done' mid-stream."); } } catch (e) { console.warn(`Failed to parse JSON line from backend fetch:`, line, e); } }
                        }
                        finalizeOrbeResponse(targetElement, accumulatedResponse, question, isError, finalResponseData);
                    } else {
                        const apiUrl = `${baseUrl}/api/generate`; let finalOptions = { ...generationParams, ...options }; if(finalOptions.stop && !Array.isArray(finalOptions.stop)) { finalOptions.stop = typeof finalOptions.stop === 'string' ? finalOptions.stop.split(',').map(s=>s.trim()).filter(s=>s) : []; } if(finalOptions.stop && finalOptions.stop.length === 0) { delete finalOptions.stop; } if(finalOptions.num_ctx === 0 || isNaN(finalOptions.num_ctx)) delete finalOptions.num_ctx; let systemPromptToSend = currentSystemPrompt || MODE_PROMPTS[selectedMode] || MODE_PROMPTS['default']; const englishInstruction = "Respond ONLY in English."; if (!systemPromptToSend.includes(englishInstruction)) { systemPromptToSend = systemPromptToSend ? `${systemPromptToSend}\n\n${englishInstruction}` : englishInstruction; }
                        const payload = { model: source, prompt: `${promptContext}${isAction ? '' : 'User: '}${question}\n\norbe:`, stream: true, options: finalOptions, system: systemPromptToSend }; console.log(`Sending request to Ollama (${source})...`);
                        const response = await fetch(apiUrl, { method: 'POST', mode: 'cors', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify(payload), signal: currentAbortController.signal });
                        if (!response.ok || !response.body) { isError = true; let errorBody = await response.text(); try { const parsedError = JSON.parse(errorBody); errorBody = parsedError.error || errorBody; } catch(e) {} throw new Error(`${source} API error: ${response.status} - ${errorBody}`); }
                        const reader = response.body.getReader(); const decoder = new TextDecoder(); let partialLine = ""; let isFirstStreamChunk = true; const targetElement = thinkingMessageElement;
                        while(true) {
                            const {value, done} = await reader.read();
                            if (done) { isGeneratingStream = false; console.log("Ollama direct stream finished."); if (partialLine.trim()) { try { const parsed=JSON.parse(partialLine); if(parsed.response){ if(isFirstStreamChunk && targetElement){ targetElement.innerHTML = targetElement.querySelector('.message-label')?.outerHTML || ''; isFirstStreamChunk = false; } if(targetElement) { targetElement.appendChild(document.createTextNode(parsed.response)); } accumulatedResponse += parsed.response; } if(parsed.done) finalResponseData=parsed;} catch(e){} } if (isFirstStreamChunk && targetElement && targetElement.textContent.endsWith('...')) { targetElement.innerHTML = targetElement.querySelector('.message-label')?.outerHTML || ''; } break; }
                            const chunk = decoder.decode(value, { stream: true }); const lines = (partialLine + chunk).split('\n'); partialLine = lines.pop() || "";
                            for (const line of lines) { if (line.trim() === "") continue; try { const parsed = JSON.parse(line); const responseChunk = parsed.response; if (responseChunk) { if (isFirstStreamChunk && targetElement) { targetElement.innerHTML = targetElement.querySelector('.message-label')?.outerHTML || ''; isFirstStreamChunk = false; } if (targetElement) { targetElement.appendChild(document.createTextNode(responseChunk)); accumulatedResponse += responseChunk; scrollToBottom(); } } if (parsed.done) { finalResponseData = parsed; console.log(`${source} response 'done'. Stats:`, finalResponseData); } } catch(e) { console.warn(`Failed to parse JSON line from ${source} stream:`, line, e); } }
                        }
                        finalizeOrbeResponse(targetElement, accumulatedResponse, question, isError, finalResponseData);
                    }
                } catch (error) {
                    isError = true; isGeneratingStream = false; orbAnimationMode = 'relaxed';
                    const wasAborted = error.name === 'AbortError';
                    console.error(`Error during ${source} request setup or fetch:`, error);
                    let errorMsg = wasAborted ? "Generation stopped by user." : `Error: ${error.message}`;
                    if (error instanceof TypeError && error.message.includes('fetch')) { let serviceName = (source === BACKEND_SOURCE_VALUE) ? "orbe Backend" : "Ollama"; let apiUrlGuess = (source === BACKEND_SOURCE_VALUE) ? `/api/search-and-chat` : baseUrl; errorMsg += `\n\nIs the ${serviceName} running and accessible at ${apiUrlGuess}? Check CORS if needed (OLLAMA_ORIGINS).`; }
                    else if (!window.electronAPI && source === BACKEND_SOURCE_VALUE) { errorMsg = "Error: Cannot communicate with backend via IPC. Is this running in the Electron app?"; }
                    finalizeOrbeResponse(thinkingMessageElement, errorMsg, question, true);
                }
            }

            function finalizeOrbeResponse(finalElement, responseText, originalQuestion, isError, stats = null) {
                orbAnimationMode = 'relaxed';
                let cleanedResponseText = responseText;
                try { // Remove <think> blocks
                    const thinkBlockRegex = /<think>[\s\S]*?<\/think>\n*/g;
                    const potentiallyCleaned = responseText.replace(thinkBlockRegex, '').trim();
                    if (potentiallyCleaned !== responseText) { cleanedResponseText = potentiallyCleaned; console.log("Cleaned response text (removed <think>):", cleanedResponseText); }
                } catch (regexError) { console.error("Error removing <think> blocks:", regexError); }

                try {
                    if (finalElement && finalElement.parentNode) {
                        finalElement.classList.remove('thinking-message');
                        if (isError || !cleanedResponseText.trim()) {
                             const errorMsg = cleanedResponseText || (isError ? "An unknown error occurred." : "Empty response.");
                             const labelHtml = finalElement.querySelector('.message-label')?.outerHTML || '';
                             finalElement.textContent = ''; finalElement.classList.add('orbe-message', 'error');
                             finalElement.innerHTML = `${labelHtml}<i>${escapeHtml(errorMsg).replace(/\n/g, '<br>')}</i>`;
                        } else {
                             finalElement.classList.add('orbe-message');
                             const processedHtml = processMessageContent(cleanedResponseText, false);
                             const aiLabel = (currentSource === BACKEND_SOURCE_VALUE) ? 'Orbe (Web)' : 'Orbe';
                             finalElement.innerHTML = `<span class="message-label">${aiLabel}:</span>${processedHtml}`;
                             if (!finalElement.querySelector('.code-block-wrapper') && typeof createCopyButton === 'function') { finalElement.appendChild(createCopyButton(cleanedResponseText)); }
                             if (typeof Prism !== 'undefined') { requestAnimationFrame(() => { try { if (finalElement?.parentNode) Prism.highlightAllUnder(finalElement); } catch(prismErr){ console.error("Prism error during finalization:", prismErr); } }); }
                        }
                    }
                    if (originalQuestion) { chatHistory.push({ question: originalQuestion, answer: cleanedResponseText, source: currentSource, mode: selectedMode, options: { ...generationParams }, timestamp: new Date(), isError: isError }); saveChatHistory(); }
                    if (!isError && originalQuestion) { saveLastSubmission(originalQuestion, buildContext(), currentSource, generationParams); }
                    if (isTtsEnabled && !isError && cleanedResponseText.trim()) { speakText(cleanedResponseText); } else { orbAnimationMode = 'relaxed'; }
                    if (systemInfo && !isError && stats && stats.total_duration) { const durationSec = (stats.total_duration / 1e9).toFixed(2); const evalRate = (stats.eval_duration > 0 ? (stats.eval_count / (stats.eval_duration / 1e9)) : 0).toFixed(1); const promptRate = (stats.prompt_eval_duration > 0 ? (stats.prompt_eval_count / (stats.prompt_eval_duration / 1e9)) : 0).toFixed(1); systemInfo.textContent = `Done (${durationSec}s). Eval: ${evalRate} t/s. Prompt: ${promptRate} t/s.`; systemInfo.style.opacity = '1'; systemInfo.style.color = '#666'; setTimeout(() => { systemInfo.style.opacity = '0'; }, 6000); }
                    else if (systemInfo && isError) { systemInfo.textContent = `Error: ${cleanedResponseText.split('\n')[0].substring(0, 100)}...`; systemInfo.style.color = 'orange'; systemInfo.style.opacity = '1'; }
                } catch (e) { console.error("Error finalizing response:", e); }
                finally {
                    thinkingFlag = false; currentAbortController = null; thinkingMessageElement = null;
                    if (!isSpeaking && !isListening) { showInputControls(true); hideTtsControls(); }
                    if (!document.hidden && questionInput && !questionInput.disabled && !isListening) { try { questionInput.focus(); } catch(e){} }
                }
            }

            async function initializeOrb() {
                 console.log("Initializing orbe...");
                 if(systemInfo) { systemInfo.textContent = "Status: Initializing..."; systemInfo.style.opacity = '1'; }
                 createParamInfoTooltip();
                 loadPresets(); populatePresetSelector();
                 if ('Notification' in window && Notification.permission !== 'denied') { Notification.requestPermission().then(permission => { console.log(`Notification permission: ${permission}`); }); }
                 const voicePromise = new Promise((resolve) => { if (!('speechSynthesis' in window)) { console.warn("Speech Synthesis not supported."); resolve(); return; } const loadVoices = () => { populateVoiceList(); resolve(); }; if (window.speechSynthesis.getVoices().length > 0) loadVoices(); else if (speechSynthesis.onvoiceschanged !== undefined) speechSynthesis.onvoiceschanged = loadVoices; else { console.warn("onvoiceschanged not supported, using timeout fallback for voices."); setTimeout(loadVoices, 600); } });
                 await voicePromise;
                 loadSettings(); await loadAndDisplaySettings(); await fetchAndPopulateModels(); loadChatHistory(); renderChatHistory();
                 console.log("Initializing Speech Recognition...");
                 const MicButtonRefForInit = getElem('micButton', false);
                 if (!SpeechRecognition) { console.warn("Web Speech Rec not supported."); if (MicButtonRefForInit) { MicButtonRefForInit.disabled = true; MicButtonRefForInit.title = "Voice N/A"; MicButtonRefForInit.style.opacity = '0.5'; } }
                 else { try { recognition = new SpeechRecognition(); recognition.continuous = false; recognition.lang = 'en-US'; recognition.interimResults = false; recognition.maxAlternatives = 1; setupRecognitionHandlers(); console.log("Speech Rec initialized."); } catch (e) { console.error("Speech Rec init failed:", e); recognition = null; if (MicButtonRefForInit) { MicButtonRefForInit.disabled = true; MicButtonRefForInit.title = "Voice Fail"; MicButtonRefForInit.style.opacity = '0.5'; } } }
                 if ('speechSynthesis' in window) window.speechSynthesis.cancel(); isSpeaking = false; orbAnimationMode = 'relaxed'; resetTtsControls();
                 if(ffRateDisplay) ffRateDisplay.textContent = `${ttsRates[currentRateIndex].toFixed(1)}x`; if(fastForwardButton) fastForwardButton.title = `Cycle Speech Rate (Now ${ttsRates[currentRateIndex].toFixed(1)}x, Next: ${ttsRates[(currentRateIndex + 1) % ttsRates.length].toFixed(1)}x)`;
                 if(playPauseButton && playPauseIcon) { playPauseButton.classList.add('paused'); playPauseButton.classList.remove('playing', 'tts-playing'); playPauseButton.title = 'Play Speech'; playPauseIcon.setAttribute('data-feather', 'play'); }
                 console.log("Setting up Event Listeners...");
                 setupEventListeners();
                 showInputControls(true);
                 if(regenerateButton) regenerateButton.style.display = lastSubmission.prompt ? 'inline-flex' : 'none';
                 clearAttachment();
                 let canRunBg = false, canRunOrb = false; if(bgCtx) { canRunBg = setupBgCanvas(); if(canRunBg) initBgParticles(); } if (setupOrbCanvas() && orbCtx) { initOrbParticles(); canRunOrb = true; } startAnimations();
                 console.log("Applying Feather Icons (Delayed)...");
                 setTimeout(() => { try { if (typeof feather !== 'undefined' && feather) { console.log("Feather replace running..."); feather.replace({ 'stroke-width': 1.8 }); } else { console.warn("Feather object missing."); } } catch (fe) { console.error("Final Feather replace failed:", fe); } }, 250);
                 setTimeout(() => { if (systemInfo && systemInfo.textContent === "Status: Initializing...") { systemInfo.style.opacity = '0'; systemInfo.textContent = "Status: Ready"; } }, 3000);
                 if (systemInfo && !systemInfo.textContent.startsWith("Error")) { systemInfo.textContent = "Status: Ready"; }
                 console.log("orbe Initialized."); if(questionInput && !questionInput.disabled && !isListening) questionInput.focus();
                 if (window.electronAPI) { window.electronAPI.onBackendError((errorMsg) => { console.error("From Main/Backend:", errorMsg); systemInfo.textContent = `Backend Error: ${errorMsg.substring(0,100)}...`; systemInfo.style.color='orange'; systemInfo.style.opacity='1'; }); window.electronAPI.onBackendLog((log) => { console.log("From Backend:", log); }); window.electronAPI.onSettingsSaved((success) => { console.log("Settings save confirmed by main process:", success); }); }
                 if (window.location.protocol === 'file:') { console.warn("Music Player Warning: May not function correctly when run as local file."); if (!sessionStorage.getItem('fileProtocolWarningShown')) { alert("Music Player may not work correctly when running orbe as a local file..."); sessionStorage.setItem('fileProtocolWarningShown', 'true'); } }
            }

            function setupEventListeners() {
                 // Input Handling & Submission
                 questionInput?.addEventListener('keydown', async (e) => { if (e.key === 'Enter' && !e.shiftKey && !thinkingFlag && currentSource && !isListening) { e.preventDefault(); const question = questionInput.value.trim(); if (question) { const questionToSend = question; displayMessage(questionToSend, true); questionInput.value = ''; adjustTextareaHeight(); const context = buildContext(); await askQuestionInternal(questionToSend, context, currentSource, generationParams); } } else if (e.key === 'Enter' && e.shiftKey) { /* Allow shift+enter */ } else if (e.key === 'ArrowUp' && chatHistory.length > 0 && questionInput.selectionStart === 0) { e.preventDefault(); const lastUserQuestion = chatHistory[chatHistory.length - 1]?.question; if (lastUserQuestion) { questionInput.value = lastUserQuestion; adjustTextareaHeight(); questionInput.focus(); questionInput.setSelectionRange(questionInput.value.length, questionInput.value.length); } } });
                 questionInput?.addEventListener('input', adjustTextareaHeight);
                 questionInput?.addEventListener('paste', () => setTimeout(adjustTextareaHeight, 0));

                 // Generation Control
                 stopGeneratingButton?.addEventListener('click', () => { if (currentAbortController) { console.log("User requested stop."); currentAbortController.abort(); isGeneratingStream = false; orbAnimationMode = 'relaxed'; finalizeOrbeResponse(thinkingMessageElement, "Generation stopped by user.", lastSubmission.prompt || "Stopped generation", true); } });
                 regenerateButton?.addEventListener('click', regenerateLastResponse);

                 // Chat Management
                 clearChatButton?.addEventListener('click', () => { if (confirm('Clear chat history? This cannot be undone.')) { chatHistory = []; chatDisplayArea.innerHTML = ''; lastSubmission = {}; if(regenerateButton) regenerateButton.style.display = 'none'; window.speechSynthesis.cancel(); resetTtsControls(); saveChatHistory(); } });
                 clearContextButton?.addEventListener('click', clearChatContext);
                 exportChatButton?.addEventListener('click', exportChat);
                 importChatsButton?.addEventListener('click', triggerImportChats);
                 importChatsInput?.addEventListener('change', importChats);

                 // Model & Mode Selection
                 modelSelector?.addEventListener('change', (e) => { currentSource = e.target.value; saveSettings(); updateUiForSource(); });
                 modeSelector?.addEventListener('change', (e) => { selectedMode = e.target.value; if (selectedMode !== 'custom') { currentSystemPrompt = MODE_PROMPTS[selectedMode] || MODE_PROMPTS['default']; } else { const settings = localStorage.getItem(SETTINGS_STORAGE_KEY) ? JSON.parse(localStorage.getItem(SETTINGS_STORAGE_KEY)) : {}; currentSystemPrompt = settings.systemPrompt || ""; } /* updateModeSelectorTooltip(); */ saveSettings(); });
                 refreshModelsButton?.addEventListener('click', async () => { refreshModelsButton.disabled = true; refreshModelsButton.innerHTML = '<i data-feather="loader" class="spin"></i>'; if (typeof feather !== 'undefined') feather.replace(); await fetchAndPopulateModels(); refreshModelsButton.innerHTML = '<i data-feather="refresh-ccw"></i>'; if (typeof feather !== 'undefined') feather.replace(); refreshModelsButton.disabled = false; });
                 modelInfoButton?.addEventListener('click', showModelInfo);
                 modelInfoOkButton?.addEventListener('click', closeModelInfo);
                 modelInfoCloseButton?.addEventListener('click', closeModelInfo);
                 deleteModelButton?.addEventListener('click', deleteOllamaModel);

                 // System Prompt Modal
                 systemPromptButton?.addEventListener('click', openSystemPromptEditor);
                 systemPromptSaveButton?.addEventListener('click', saveSystemPrompt);
                 systemPromptCancelButton?.addEventListener('click', closeSystemPromptEditor);
                 systemPromptCloseButton?.addEventListener('click', closeSystemPromptEditor);

                 // TTS Controls
                 ttsToggleButton?.addEventListener('click', () => { isTtsEnabled = !isTtsEnabled; updateTtsButtonState(); if (!isTtsEnabled) { window.speechSynthesis.cancel(); resetTtsControls(); } saveSettings(); });
                 voiceSelector?.addEventListener('change', (e) => { const index = parseInt(e.target.value, 10); selectedVoice = (index >= 0 && index < availableVoices.length) ? availableVoices[index] : null; console.log("Voice selected:", selectedVoice?.name || "Default"); saveSettings(); });
                 playPauseButton?.addEventListener('click', () => { if (isSpeaking) { if (speechSynthesis.paused) { speechSynthesis.resume(); orbAnimationMode = 'speaking'; playPauseButton.classList.remove('paused'); playPauseButton.classList.add('playing', 'tts-playing'); playPauseButton.title = 'Pause Speech'; if(playPauseIcon) playPauseIcon.setAttribute('data-feather', 'pause'); } else { speechSynthesis.pause(); orbAnimationMode = 'relaxed'; playPauseButton.classList.add('paused'); playPauseButton.classList.remove('playing', 'tts-playing'); playPauseButton.title = 'Resume Speech'; if(playPauseIcon) playPauseIcon.setAttribute('data-feather', 'play'); } try { if (typeof feather !== 'undefined' && feather) feather.replace({ 'stroke-width': 1.8, width: 14, height: 14 }); } catch(e) { console.warn("Feather error updating play/pause icon", e); } } else { console.log("Play button clicked, but nothing is actively speaking or paused."); } });
                 fastForwardButton?.addEventListener('click', () => { currentRateIndex = (currentRateIndex + 1) % ttsRates.length; const newRate = ttsRates[currentRateIndex]; if(ffRateDisplay) ffRateDisplay.textContent = `${newRate.toFixed(1)}x`; fastForwardButton.title = `Cycle Speech Rate (Now ${newRate.toFixed(1)}x, Next: ${ttsRates[(currentRateIndex + 1) % ttsRates.length].toFixed(1)}x)`; if (currentUtterance) { currentUtterance.rate = newRate; if (isSpeaking || speechSynthesis.paused) { const textToSpeakAgain = currentUtterance.text; const wasPaused = speechSynthesis.paused; window.speechSynthesis.cancel(); speakText(textToSpeakAgain, false, false, null); if (wasPaused) { setTimeout(() => { if (isSpeaking && !speechSynthesis.paused){ speechSynthesis.pause(); orbAnimationMode = 'relaxed'; playPauseButton?.classList.add('paused'); playPauseButton?.classList.remove('playing', 'tts-playing'); playPauseButton.title = 'Resume Speech'; if(playPauseIcon) playPauseIcon.setAttribute('data-feather', 'play'); if (typeof feather !== 'undefined') feather.replace({ 'stroke-width': 1.8, width: 14, height: 14 }); } }, 100); } } } });

                 // Snippets Panel
                 toggleSnippetsButton?.addEventListener('click', () => { snippetsPanel.style.display = snippetsPanel.style.display === 'block' ? 'none' : 'block'; if (snippetsPanel.style.display === 'block') { renderSnippetsPanel(); } });
                 snippetsList?.addEventListener('click', (e) => { const target = e.target; if (target.classList.contains('delete-snippet-button')) { const index = parseInt(target.dataset.index, 10); if (!isNaN(index)) deleteSnippet(index); } else if (target.classList.contains('use-snippet-button')) { const index = parseInt(target.dataset.index, 10); if (!isNaN(index)) useSnippet(index); } });

                 // Generation Parameters & Presets
                 paramGrid?.addEventListener('input', handleParamChange);
                 paramGrid?.addEventListener('change', handleParamChange);
                 resetParamsButton?.addEventListener('click', resetParameters);
                 paramGrid?.addEventListener('mouseover', (e) => { const infoButton = e.target.closest('.info-button'); if (infoButton) { showParamInfoTooltip(infoButton); } });
                 paramGrid?.addEventListener('mouseout', (e) => { const infoButton = e.target.closest('.info-button'); if (infoButton && infoButton === currentInfoButton) { setTimeout(() => { if (!paramInfoTooltip || !paramInfoTooltip.matches(':hover')) { hideParamInfoTooltip(); } }, 100); } else if (!e.target.closest('.info-button') && !e.target.closest('#paramInfoTooltip')) { hideParamInfoTooltip(); } });
                 paramGrid?.addEventListener('click', (e) => { const infoButton = e.target.closest('.info-button'); if (infoButton) { e.stopPropagation(); showParamInfoTooltip(infoButton); } });
                 presetSelector?.addEventListener('change', loadSelectedPreset);
                 savePresetButton?.addEventListener('click', saveCurrentPreset);
                 deletePresetButton?.addEventListener('click', deleteSelectedPreset);
                 exportPresetsButton?.addEventListener('click', exportPresets);
                 importPresetsButton?.addEventListener('click', triggerImportPresets);
                 importPresetsInput?.addEventListener('change', importPresets);

                 // File Attachment
                 attachFileButton?.addEventListener('click', triggerAttachFile);
                 attachFileInput?.addEventListener('change', handleFileAttach);
                 clearAttachmentButton?.addEventListener('click', clearAttachment);

                 // Code Block Actions (Event Delegation)
                 chatDisplayArea?.addEventListener('click', (e) => { const button = e.target.closest('button'); if (!button) return; const codeWrapper = button.closest('.code-block-wrapper'); let code = button.dataset.code || codeWrapper?.querySelector('textarea.inline-code-textarea')?.value; const lang = button.dataset.lang || codeWrapper?.querySelector('textarea.inline-code-textarea')?.dataset.lang || codeWrapper?.querySelector('.code-language-label')?.textContent || 'plaintext'; if (button.classList.contains('save-snippet-button')) { addSnippet(lang, code, button); } else if (button.classList.contains('code-copy-button')) { navigator.clipboard.writeText(code).then(()=>{ flashButtonState(button, 'copied', 'copy'); }).catch(err=>{ console.error('Copy failed:', err); button.innerHTML='❌'; setTimeout(()=>{button.innerHTML=ICONS.copy || '📋';},1200); }); } else if (button.classList.contains('edit-code-button')) { startInlineEdit(button); } else if (button.classList.contains('inline-save-button')) { saveInlineEdit(button); } else if (button.classList.contains('inline-cancel-button')) { cancelInlineEdit(codeWrapper); } else if (button.classList.contains('play-code-button')) { speakText(code, true, button); } else if (button.classList.contains('use-code-button')) { questionInput.value = code; adjustTextareaHeight(); questionInput.focus(); } else if (button.matches('.action-explain-button, .action-refactor-button, .action-find-bugs-button, .action-optimize-button, .action-document-button')) { const actions = { 'action-explain-button': 'Explain this code:', 'action-refactor-button': 'Refactor this code:', 'action-find-bugs-button': 'Find potential bugs in this code:', 'action-optimize-button': 'Optimize this code:', 'action-document-button': 'Add documentation and comments to this code:' }; const actionPrefix = actions[button.classList.item(1)]; if (actionPrefix && code) { const actionPrompt = `${actionPrefix}\n\`\`\`${lang}\n${code}\n\`\`\``; const context = buildContext(); askQuestionInternal(actionPrompt, context, currentSource, generationParams, true); } } });

                 // Backend Settings
                 saveSettingsButton?.addEventListener('click', saveBackendSettings);

                 // Music Player Panel
                 if (toggleMusicPanelButton && musicPlayerPanel) { toggleMusicPanelButton.addEventListener('click', () => { musicPlayerPanel.style.display = musicPlayerPanel.style.display === 'block' ? 'none' : 'block'; }); }
                 if (closeMusicPanelButton && musicPlayerPanel) { closeMusicPanelButton.addEventListener('click', () => { musicPlayerPanel.style.display = 'none'; }); }
                 if (musicPlayerHeader && musicPlayerPanel) { makeDraggable(musicPlayerPanel, musicPlayerHeader); }
                 if (audioFileInput) audioFileInput.addEventListener('change', handleAudioFilesSelected);
                 if (playlistDisplay) playlistDisplay.addEventListener('click', handlePlaylistClick);
                 if (playPausePlayerButton) playPausePlayerButton.addEventListener('click', togglePlayPause);
                 if (nextTrackButton) nextTrackButton.addEventListener('click', playNextTrack);
                 if (prevTrackButton) prevTrackButton.addEventListener('click', playPreviousTrack);
                 if (volumeSlider) volumeSlider.addEventListener('input', handleVolumeChange);

                 // Window / Body Listeners
                 window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { if(bgCanvas) setupBgCanvas(); if(orbCanvas) setupOrbCanvas(); adjustTextareaHeight(); }, 250); });
                 document.body.addEventListener('dragover', (e) => e.preventDefault());
                 document.body.addEventListener('drop', (e) => e.preventDefault());

                 // Mic Button Listener
                 const micButtonRef = getElem('micButton', false);
                 micButtonRef?.addEventListener('click', () => { console.log("Mic button clicked. Rec available:", !!recognition); if (!recognition) { alert("Speech recognition not available/initialized."); return; } if (isListening) { console.log("-> Stopping listening."); stopListening(); } else { console.log("-> Attempting to start listening."); if (isSpeaking) { window.speechSynthesis.cancel(); resetTtsControls(); } if(navigator.mediaDevices?.getUserMedia) { navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => { stream.getTracks().forEach(track => track.stop()); console.log("Mic perm OK."); startListening(); }).catch(err => { console.error("Mic permission denied/error:", err); if (systemInfo) { systemInfo.textContent = "Mic access denied."; systemInfo.style.opacity = '1'; systemInfo.style.color = 'orange'; } updateMicButtonState(false); alert("Microphone access was denied. Please allow microphone access in your browser settings for this site and refresh the page."); }); } else { console.warn("getUserMedia unsupported. Trying direct start..."); startListening(); } } });
                 console.log("Mic button listener attached.");

                console.log("Event listeners setup COMPLETE.");
             }

            // Start Everything
            if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initializeOrb); }
            else { initializeOrb(); }

        } catch (error) {
             console.error("FATAL ORBE INITIALIZATION ERROR:", error);
             const errInfo = document.getElementById('systemInfo') || document.body.appendChild(document.createElement('div'));
             errInfo.innerHTML = `<p style="color:red; background:#300; border:1px solid red; padding:15px; margin:20px; font-size:1.1em; text-align:center; position: relative; z-index: 2000;">Critical init error.<br>Orbe cannot start. Check console (F12).</p><pre style="color:#fdd; background:#200; padding:10px; margin:0 20px 20px 20px; white-space:pre-wrap; font-size:0.9em; border:1px solid #a00;">${error.stack || error}</pre>`;
             errInfo.style.position = 'relative'; errInfo.style.zIndex = '2000';
             const container = document.querySelector('.container'); if(container) container.style.display = 'none';
             if(typeof stopAnimations === 'function') stopAnimations();
        }
    </script>
</body>
</html>